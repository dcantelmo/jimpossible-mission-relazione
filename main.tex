\documentclass[11pt,a4paper]{article}
% Language and encoding
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}

\usepackage{xcolor}
\usepackage[scaled=0.9]{beramono} % Un font monospaziato molto più bello

% Common packages
\usepackage{lmodern}
% Font leggibile a schermo
\usepackage[sfdefault,light,scaled=0.95]{FiraSans} % light weight for body text
\usepackage{FiraMono}
% Font matematico armonizzato
\usepackage{newtxmath}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{hyperref}
\hypersetup{hidelinks} % rimuove contorni colorati dai link (indice, riferimenti)
\usepackage{csquotes}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{tikz}
\usepackage{forest}
\usepackage{listings}
% Definizione colori "Flat" moderni
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.96} % Grigio chiarissimo, quasi bianco
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}

\lstset{
  language=Java,
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegray}\itshape, % Commenti in italico
  keywordstyle=\color{codepurple}\bfseries,
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codegreen},
  basicstyle=\fontsize{9}{11}\selectfont\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  frame=none, % Rimuove la cornice completa vecchia scuola
  framexleftmargin=5mm, % Margine per la linea laterale
  xleftmargin=5mm,
  % Aggiunge una barra laterale colorata moderna invece del box
  framesep=5pt,
  rulecolor=\color{codepurple}, % Colore della barra laterale
  framerule=2pt, % Spessore barra laterale
  frame=l % Solo linea a sinistra
}

% Page geometry
\geometry{margin=2.5cm}

% Metadata
\title{{\Huge Progetto: JImpossible Mission}}
\author{Daniele Cantelmo\\Matricola 1815100\\Teledidattica}
\date{Corso di Metodologie di Programmazione\\\today}

\begin{document}
\maketitle
\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{assets/main.jpg}
\end{figure}
\newpage
\tableofcontents
\newpage

\section{Introduzione}
Il documento descrive il progetto \textbf{JImpossible Mission}, un progetto didattico che consiste nella realizzazione di un videogioco
in Java basato sul classico gioco per Commodore~64 "Impossible Mission".

Il videogioco è un platform 2D in cui il giocatore controlla un agente segreto infiltrato in una base nemica.
Lo scopo del giocatore è quello di cercare e raccogliere, all'interno della base, tutti i frammenti di schede perforate disperse
e nascoste all'interno degli oggetti di scena. Una volta raccolti tutti i frammenti sarà possibile decifrare il codice di accesso alla
stanza di controllo e terminare la missione una volta raggiunta la porta.

Il gioco presenta varie meccaniche fondamentali, che definiscono il modo in cui il giocatore interagisce con l'ambiente di gioco e le sfide che deve affrontare.
Tra queste meccaniche principali troviamo:
\begin{itemize}
  \item Controllo del personaggio principale tramite tastiera
  \item Nemici con IA
  \item Interazione con oggetti collezionabili e dispositivi (PC, ascensori)
  \item Gestione delle collisioni tra entità
  \item Ascensori
  \item Suoni e animazioni
\end{itemize}
Il gioco è stato sviluppato utilizzando Java, con versione di riferimento JDK 22.
Per la gestione dei menù, della grafica e delle animazioni è stata utilizzata la libreria Java Swing.

I requisiti funzionali del progetto riguardano principalmente:
\begin{itemize}
  \item Impiego del pattern strutturale MVC (Model-View-Controller)
  \item Mondo di gioco dinamico, con entità in movimento, animazioni e suoni
  \item Ostacoli e nemici da evitare
  \item Gestione dei profili utente e persistenza dei punteggi
  \item Oggetti da raccogliere e utilizzare (Freeze, Reset ascensori ecc.)
\end{itemize}

Il gioco è stato sviluppato con l'idea di sfruttare e adottare diversi pattern di progettazione del
software, per conoscerne punti di forza e limiti.
Questo approccio ha anche reso il codice più lineare e manutenibile.
Inoltre è stata posta particolare attenzione alla separazione delle responsabilità tra le varie componenti del pattern MVC ed è stata
promossa la modularità del codice, che ha facilitato l'estensione del progetto con funzionalità aggiuntive.

\subsection{Panoramica dell'architettura}
L'architettura di \textbf{JImpossible Mission} è organizzata come segue:
\begin{itemize}
  \item \textbf{Model}: è il cuore del progetto. Gestisce le logiche del gioco, le interazioni tra le entità e rappresenta lo stato del mondo di gioco. \\[2pt]
    \textit{Subpackages}: \texttt{entity}, \texttt{manager}, \texttt{physics}, \texttt{game}, \texttt{scene}, \texttt{item}, \texttt{profile}.
  \item \textbf{View}: si occupa della rappresentazione grafica utilizzando come base \textbf{Java Swing}, estendendone i componenti. Gestisce le interfacce dei menù, le animazioni e gli effetti audio del gioco \\[2pt]
    \textit{Subpackages}: \texttt{animation}, \texttt{audio}, \texttt{color}, \texttt{hud}, \texttt{item}, \texttt{menu}, \texttt{ui}.
  \item \textbf{Controller}: riceve gli input da tastiera (tramite \texttt{InputController}), li normalizza in comandi di gioco (azioni) e li passa al Model. Contiene inoltre il \textbf{game loop}, che scandisce l'aggiornamento periodico dello stato del gioco.
\end{itemize}
\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{assets/jimpossible_overview.png}
\end{figure}
Come si evince dal diagramma, il flusso di dati principale avviene all'interno del ciclo di gioco (game loop), il Model viene aggiornato regolarmente e la View viene notificata alla fine di ogni ciclo di update per ridisegnare la scena corrente.

\section{Il Controller}
Per iniziare ad approfondire l'architettura del progetto, partiamo dal \textbf{Controller}, che rappresenta il punto di ingresso principale dell'applicazione.
Il Controller si occupa di gestire il ciclo di vita dell'applicazione, avviando e terminando il gioco in modo appropriato e gestendo le logiche tra le interfacce visualizzate.
Spetterà poi al Model e alla View di occuparsi rispettivamente dell'implementazione delle logiche e della rappresentazione grafica.

\subsection{Il Game Loop}
\label{sec:game_loop}
Una volta inizializzato il Model, e aggiunta la View del gioco ai listener del model, secondo il pattern \textbf{Observer/Observable}, il Controller avvia il \textbf{game loop}.
Il \textbf{game loop} è il ciclo principale che gestisce l'aggiornamento del gioco, ad intervalli regolari (anche se con minime fluttuazioni dovute al carico e alla velocità della CPU).
Per la realizzazione del progetto il primo passo compiuto è stata la definizione di un ciclo di aggiornamento continuo.
Grazie ad esso è possibile gestire interazioni in tempo reale (tramite \textit{polling} degli input) e aggiornare lo stato del gioco.
Nel nostro caso si utilizza un ciclo \textbf{while} che continua finché il gioco è in esecuzione e si definisce il numero di aggiornamenti desiderati in un certo intervallo di tempo.
Un buon compromesso tra fluidità e prestazioni, molto comune nel settore dei videogiochi, è impostare un aggiornamento di \textbf{60 volte al secondo}.

La logica del model viene quindi aggiornata ad ogni iterazione del ciclo, tenendo conto del tempo trascorso dall'ultimo aggiornamento, fondamentale per calcoli di movimenti con velocità e \textbf{collision resolution}.
Questo intervallo di tempo è definito come \textbf{frame time}, che rappresenta appunto il tempo minimo tra due aggiornamenti consecutivi.
Il frame time è calcolato come l'inverso del numero di aggiornamenti desiderati al secondo (FPS - Frames Per Second):
\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\(
      \text{FRAME\_TIME} = \dfrac{1}{\text{FPS}}
  \)}
\end{center}
Invece, il tempo effettivo tra due aggiornamenti consecutivi viene denominato \(\Delta t\) (delta time) e viene calcolato come la differenza tra il tempo corrente e il tempo dell'ultimo aggiornamento.
Per evitare problemi di calcolo, specie per collision manager e motori fisici, in caso di cali improvvisi di prestazioni, è buona pratica definire un \textbf{max frame time}, che limita il tempo massimo tra due aggiornamenti consecutivi.
Pertanto, per i calcoli interni al model, il \textit{delta time} viene normalizzato e limitato tra il frame time e il max frame time:
\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\(
      \Delta t = \max(\text{FRAME\_TIME}, \min(\text{MAX\_FRAME\_TIME}, \Delta t))
  \)}
\end{center}
Il codice del game loop è stato implementato nel seguente modo:

\begin{lstlisting}[language=Java]
TARGET_FPS = 60.0f;
FRAME_TIME = 1.0f / TARGET_FPS; // Timestep base
MAX_FRAME_TIME = 3.0f / TARGET_FPS; // Massima fluttuazione del timestep
private static final long FRAME_TIME_NS = (long) (FRAME_TIME * 1_000_000_000);

private static void runGameLoop(Model m, InputController inputController) {
        long lastTime = System.nanoTime();

        // gameRunning e' una variabile boolean condivisa (volatile) che indica se il gioco e' in esecuzione
        while (gameRunning && !Thread.currentThread().isInterrupted()) {
            long currentTime = System.nanoTime();
            long deltaTime = currentTime - lastTime;

            // Controlla se e' passato il tempo sufficiente per definire un frame
            if (deltaTime >= FRAME_TIME_NS) {
                float dt = deltaTime / 1_000_000_000f;
                dt = Math.max(FRAME_TIME, Math.min(MAX_FRAME_TIME, dt));
                // Aggiorna lo stato del gioco, passando il delta time normalizzato e gli input correnti
                m.updateGameState(new HashSet<>(inputController.getInputState()), dt);
                lastTime = currentTime;
            } else {
                long remainingTime = FRAME_TIME_NS - deltaTime;
                // Se manca ancora 'molto' tempo al prossimo frame, metti il thread in sleep per ridurre l'uso della CPU
                if (remainingTime > 2_000_000) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
    }
\end{lstlisting}

Il game loop inizia registrando il tempo corrente in nanosecondi.
All'interno del ciclo while calcola il tempo trascorso dall'ultimo aggiornamento (deltaTime) e, se questo tempo supera il frame time desiderato (\texttt{FRAME\_TIME\_NS}),
aggiorna lo stato del gioco chiamando il metodo \texttt{updateGameState} del Model, passando gli input correnti e il delta time normalizzato.
Dopo l'aggiornamento imposta \texttt{lastTime} al tempo corrente; se invece il \textit{deltaTime} è inferiore al frame time,
il thread dorme per un breve periodo per evitare un utilizzo eccessivo della CPU (\textit{busy waiting}).

Ad ogni iterazione del ciclo viene inoltre passato al Model lo stato corrente degli input raccolti dal Controller.
\subsection{L'InputController}
Per semplificare il passaggio degli input al Model, è stata definita una classe chiamata \textbf{InputController} che si occupa di catturare gli input da tastiera, implementando l'interfaccia \texttt{KeyListener} di Java Swing.
\begin{lstlisting}[language=Java]
  public class InputController implements KeyListener {
    private final Set<Integer> pressedKeys = ConcurrentHashMap.newKeySet();

    @Override
    public void keyTyped(KeyEvent e) {
        // No-op
    }

    @Override
    public void keyPressed(KeyEvent e) {
        pressedKeys.add(e.getKeyCode());
    }

    // Rimuove il keyCode dal set al release del tasto.
    @Override
    public void keyReleased(KeyEvent e) {
        pressedKeys.remove(e.getKeyCode());
    }

    public Set<Action> getInputState() {
        return pressedKeys.stream().map(Action::fromKeyCode)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
    }
}
\end{lstlisting}
La logica alla base di questa classe è semplice: mantiene un insieme di tasti attualmente premuti (pressedKeys) e aggiorna questo insieme in risposta agli eventi di pressione e rilascio dei tasti.
Il metodo \texttt{getInputState} restituisce lo stato corrente degli input che verranno successivamente filtrati e mappati in azioni di gioco dal Model.
In questo modo il Model lavora esclusivamente con azioni astratte (\texttt{Action}) e rimane disaccoppiato dai dettagli specifici dei codici di tastiera e di Java Swing.
\newpage
\subsection{Gestione delle interfacce}
Il Controller si occupa anche di connettere le varie interfacce grafiche passando le funzioni che verranno eseguite al verificarsi di determinati \textit{input} dell'utente.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{assets/menu_navigation.png}
\end{figure}
Quando vengono eseguiti determinati comandi nella View, il Controller si occuperà di eseguire le azioni corrispondenti, come avviare la partita, salvare le modifiche ai profili utente e interfacciarsi con il model per caricare o salvare i dati.

\section{Analisi e pianificazione del gioco}
Prima di proseguire con lo sviluppo delle logiche di gioco, bisogna soffermarsi su come sviluppare e riprodurre alcuni punti fondamentali.
Questo processo inizia con l'individuare le entità principali di gioco, il piano di riferimento del mondo di gioco all'interno del Model e come viene riportato visivamente nella View.
\subsection{Geometrie e coordinate}
Per la gestione delle posizioni è stato individuato un sistema di coordinate cartesiane 2D, con l'origine (0,0) nell'angolo in alto a sinistra dello schermo, definito da una coppia di valori interi (x,y).
Il sistema è stato sviluppato ragionando in \textbf{pixel}, in modo da semplificare i calcoli di posizionamento e movimento delle entità ed uniformare poi il calcolo che verrà effettuato nella View.
\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\parbox{0.9\linewidth}{\small
      Nonostante si lavori in pixel, il Model non ha una vera e propria "risoluzione". E' però un'astrazione che aiuta a definire le logiche di posizionamento.
      Le dimensioni delle entità e della finestra possono essere \textit{scalate} a piacimento nel layer di presentazione, preservando \textbf{integralmente} le logiche sottostanti.
  }}
\end{center}
I vari scenari sono stati progettati su una griglia di \textbf{32x32} pixel per cella, individuati come Tile e utilizzati per posizionare pavimenti, muri, oggetti di scena e piattaforme.
Di conseguenza, la dimensione di ogni stanza è stata definita come multiplo di 32 pixel, andando a definire un'area di gioco di \textbf{40x25} tiles (width x height),
una dimensione che si adatta bene alla tipologia di gioco ed è simile alla grandezza delle mappe originali. Le entità nel Model, verranno dimensionate in base al rapporto di grandezza rispetto alla dimensione del tile.

\subsection{Movimento e formula della velocità}
\label{sec:movement_overview}
Una volta definite le unità di misura e la griglia di riferimento, il movimento delle entità viene calcolato tenendo conto della loro velocità e del tempo trascorso tra un aggiornamento e l'altro del game loop.
In termini continui, la posizione viene aggiornata usando la classica formula:
\[
  \text{nuovaPosizione} = \text{posizioneCorrente} + \text{velocità} \cdot \Delta t
\]
dove la velocità è espressa in \emph{pixel al secondo} e \(\Delta t\) è il tempo trascorso tra due frame consecutivi (in secondi), calcolato e normalizzato come descritto nella sezione~\ref{sec:game_loop}.

Nel codice questo concetto è rappresentato tramite il vettore bidimensionale \textbf{Vector2}, che memorizza la velocità orizzontale e verticale (\(v_x, v_y\)). Ad ogni aggiornamento, in base ai tasti premuti o alle forze applicate,
gli stati del Player e dei nemici aggiornano la velocità desiderata e richiedono uno spostamento espresso in pixel:
\[
  \Delta x = v_x \cdot \Delta t, \quad \Delta y = v_y \cdot \Delta t
\]
Questo spostamento viene poi passato al sistema di collisioni, che lo "corregge" per evitare la penetrazione nei blocchi solidi.
In questo modo il gioco resta fluido anche in presenza di piccole variazioni nel frame time, preservando coerenza e responsività dei controlli.

\subsection{Costruzione delle mappe}
\label{sec:map_building}
Per agevolare lo sviluppo, il debug dei vari livelli e la creazione di nuove mappe, è stato pensato un semplice formato di file di testo, rappresentante la griglia di tiles e le entità presenti con caratteri ASCII.
\begin{lstlisting}[language=Java]
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . @ . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . ~ . . . . . . . . . . . . . . . . . . . |
| . X . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . # # # # # # # # # # # # # # . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . # # # # # . . . . . . ~ . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . # # # # # # # # # # # # # . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
> . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . >
> . . . . . . . @ . . . . . . . . @ . . . . . . . | . . . . . . . . . . . . . >
> . . . . . . . . . . . . C . . . . . . . . . . . | . . . . . C . . . . . . . >
> . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . >
> . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . >
# # # # # # # # # # # # # # # # # # # # # # ^ . . | ^ . . # # # # # # # # # # #
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
\end{lstlisting}
In questo modo i livelli possono essere creati e modificati facilmente tramite editor di testo, fornendo una rappresentazione semplificata della disposizione delle entità e degli oggetti all'interno del gioco.
Ogni carattere rappresenta un diverso tipo di tile o entità, ad esempio:
\begin{itemize}
  \item \texttt{.} : Spazio vuoto
  \item \texttt{\#} : Pavimento
  \item \texttt{X} : Uscita
  \item \texttt{@} : Nemico
  \item \texttt{C} : Computer
  \item \texttt{\textasciitilde} : Collezionabile
  \item \texttt{\^} : Ascensore
  \item \texttt{>} : Porte della stanza
\end{itemize}
Il parsing di questi file di testo avviene all'avvio del gioco; verranno illustrati in seguito i dettagli tecnici dell'implementazione.
\subsection{Sistema di collisioni}
\label{sec:collision_system_overview}
Il gioco, essendo un platform 2D, richiede un sistema di gestione delle collisioni.
Non avendo meccaniche particolari legate alle animazioni o hitbox dinamiche, si può implementare un sistema basato su \textbf{Axis-Aligned Bounding Box} (AABB), in modo da semplificare calcoli di intersezione e non appesantire la macchina.
Ogni entità solida (muri, pavimenti, piattaforme, ascensori) avrà una hitbox rettangolare definita dalle sue coordinate e dimensioni.
Le entità mobili (player, nemici) avranno anch'esse una hitbox AABB, e ad ogni aggiornamento del game loop, il sistema di collisioni verificherà se la hitbox di un'entità mobile interseca quella di un'entità solida.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{assets/AABB_collision.png}
  \caption{Esempio di collisione AABB (fonte: \href{https://www.amanotes.com/post/using-swept-aabb-to-detect-and-process-collision}{Amanotes}).}
\end{figure}

\newpage
\section{Panoramica del Model}
Il Model, sviluppato con pattern \textbf{Singleton}, implementa l'interfaccia \textbf{Observable} per notificare alla View gli aggiornamenti dello stato di gioco.
Il punto di ingresso principale del Model è il metodo \texttt{updateGameState}, che viene chiamato ad ogni iterazione del game loop, ricevendo in input i comandi e il tempo trascorso dall'ultimo aggiornamento (\(\Delta t\)).

Il mondo di gioco è rappresentato da una serie di strutture dati e entità che rappresentano in maniera logica i vari aspetti del gioco.
Queste strutture dati sono organizzate in vari package all'interno del Model, ognuno con una responsabilità specifica.
\subsection{Unità geometriche e fisiche}
\label{sec:game_geometry}
Per posizionare correttamente le entità nel mondo di gioco, il progetto definisce due geometrie fondamentali:
\begin{itemize}
  \item \textbf{Point}: rappresenta una posizione nel mondo di gioco, definita da una coppia di coordinate intere (x,y)
  \item \textbf{Bounds}: rappresenta un'area rettangolare nel mondo di gioco, definita da due punti (Point) che rappresentano l'angolo in alto a sinistra e l'angolo in basso a destra del rettangolo.
\end{itemize}
Queste classi forniscono metodi per calcolare intersezioni, verificare se un punto è contenuto all'interno di un'area e altre operazioni geometriche fondamentali.
Per la gestione dei movimenti invece è stata definita la classe \textbf{Vector2}, su ispirazione del \textit{motore Unity}, che rappresenta un vettore bidimensionale composto da due componenti \textbf{float}.
La classe implementa inoltre le funzioni matematiche di base per operare con i vettori, come somma, moltiplicazione per uno scalare, normalizzazione, ma espone anche metodi di comodo come cambio di direzione e conversione in Point.

Il gioco inoltre ha richiesto l'utilizzo di un semplice motore fisico per gestire i movimenti di una tipologia di nemico e per simulare la gravità sul giocatore.
Per questo scopo è stata definita la classe \textbf{Force}, rappresentata da un Vector2 e da un \textbf{ForceType} (enum IMPULSE, CONSTANT).
L'idea di base è che le forze di tipo IMPULSE vengono applicate una sola volta (es. salto del giocatore) e si consumano, mentre le forze di tipo CONSTANT vengono applicate ad ogni aggiornamento (es. gravità).

\subsection{Entity e pattern di progettazione}
Il package Entity le classi che rappresentano ogni entità del gioco: dai blocchi statici come muri e pavimenti, alle entità dinamiche come il giocatore.
Alla base di ogni entità è stata individuata la classe astratta \textbf{Entity}, che definisce le proprietà comuni a tutte le entità:
\begin{itemize}
  \item ID univoco
  \item Posizione
  \item Funzioni di rimozione dal gioco
  \item Metodi astratti per eventi come \textit{onRoomLeave}, \textit{onRoomReset} ecc. che verranno implementati dalle sottoclassi
\end{itemize}
\begin{figure}[h]
  \centering
  \includegraphics[width=0.65\textwidth,height=0.2\textheight,keepaspectratio]{assets/entity_uml.png}
\end{figure}
La classe Entity viene poi estesa per comporre le entità specifiche del gioco, come \texttt{Player} e \texttt{Robot}, implementando interfacce aggiuntive
utilizzate per categorizzare le entità all'interno dei rispettivi manager: ad esempio, il Player implementa le interfacce \texttt{ActionReceiver}, \texttt{BoundingBox}, \texttt{Interactor} e \texttt{Damageable},
quindi il sistema saprà che il Player può ricevere azioni, ha una hitbox per le collisioni, può interagire con oggetti e può subire danni.

\subsubsection{\textit{Interfaces}, \textit{Managers} e composizione delle entità}
Come anticipato, le interfacce utilizzate nel Model sono caratterizzanti della tipologia entità e vengono utilizzate dai vari manager per specifiche funzionalità:
\begin{itemize}
  \item \textbf{Damageable}: espone un getter per un BoundingBox che rappresenta l'area in cui l'entità può subire danni
  \item \textbf{Damager}: espone un getter per un BoundingBox che rappresenta l'area in cui l'entità può infliggere danni
  \item \textbf{Ephemeral}: interfaccia marker per entità che devono essere rimosse in fase di cleanup (es. proiettili, shockray dei Robot)
  \item \textbf{Interactable}: espone un getter per un BoundingBox che rappresenta l'area in cui l'entità può essere interagita
  \item \textbf{Interactor}: espone un getter per un BoundingBox che rappresenta l'area in cui l'entità può interagire con altre entità
  \item \textbf{Solid}: interfaccia marker per entità solide, come muri, pavimenti e ascensori
  \item \textbf{Static}: interfaccia marker per entità statiche, che non hanno alcuna funzionalità di movimento (muri, pavimenti ecc.)
\end{itemize}
\begin{figure}[h]
  \centering
  \includegraphics[width=0.85\textwidth]{assets/interfaces.png}
\end{figure}
La lista di interfacce non è esaustiva, ma rappresenta i principali metodi di categorizzazione delle entità.

I \textbf{Manager} delle entità, in questo software, sono istanze che si occupano di gestire le logiche di collisione in base alle interfacce integrate nelle entità.
Sono presenti 3 tipi principali di manager:
\begin{itemize}
  \item \textbf{CollisionManager}: specializzato nella gestione delle collisioni tra entità solide (Solid) e nel risolvere i movimenti di Player e nemici in movimento, verrà descritto in dettaglio nella sezione relativa alle collisioni.
  \item \textbf{EntityManager}: contiene e gestisce tutte le entità presenti nel contesto corrente e getters per ottenere liste di entità in base a specifiche interfacce (es. tutti i Damager presenti)
  \item \textbf{ComponentManager}: classe astratta di supporto per tutti i manager basati su componenti; incapsula la logica di recupero e filtraggio dei candidati in un'area, permettendo di rilevare interazioni tra entità che espongono determinate interfacce (es. Interactor vs Interactable, Damager vs Damageable)
\end{itemize}
Si riporta di seguito la classe \textbf{ComponentManager}.
\begin{lstlisting}[language=Java]
  /**
  * Manager generico per componenti di tipo {@code T}.
  * Fornisce utilita' per recuperare candidati e filtrarli per area e tipo.
  *
  * @param <T> tipo degli elementi gestiti
  */
  public abstract class ComponentManager<T> {
    protected final EntityManager entityManager;

    /**
    * Funzione che mappa un elemento {@code T} ai suoi {@link Bounds} per i test di intersezione.
    */
    private final Function<T, Bounds> getCandidateBounds;

    /**
    * Costruisce un ComponentManager con il relativo EntityManager e la funzione di bounds.
    *
    * @param entityManager      gestore delle entita'
    * @param getCandidateBounds funzione che ritorna i bounds per ciascun candidato
    */
    public ComponentManager(EntityManager entityManager,
    Function<T, Bounds> getCandidateBounds) {
      this.entityManager = entityManager;
      this.getCandidateBounds = getCandidateBounds;
    }

    /**
    * Restituisce la lista completa dei candidati gestiti.
    *
    * @return lista di candidati di tipo {@code T}
    */
    public abstract List<T> getCandidates();

    /**
    * Filtra i candidati i cui bounds intersecano gli {@code actorBounds} forniti.
    *
    * @param actorBounds bounds di riferimento per il filtro
    * @return stream di candidati che intersecano {@code actorBounds}
    */
    private Stream<T> getCandidatesInAreaStream(Bounds actorBounds) {
      return getCandidates().stream().filter(el -> getCandidateBounds.apply(el).intersects(actorBounds));
    }

    /**
    * Restituisce i candidati nell'area castati al tipo richiesto.
    *
    * @param actorBounds area di ricerca
    * @param type        classe del tipo desiderato
    * @param <U>         tipo di ritorno richiesto
    * @return lista di elementi di tipo {@code U} presenti nell'area
    */
    public <U> List<U> getCandidatesInAreaByType(Bounds actorBounds, Class<U> type) {
      return getCandidatesInAreaStream(actorBounds).filter(type::isInstance).map(type::cast).toList();
    }

    /**
    * Restituisce il primo candidato nell'area che e' istanza del tipo richiesto.
    *
    * @param actorBounds area di ricerca
    * @param type        classe del tipo desiderato
    * @param <U>         tipo opzionale di ritorno
    * @return Optional contenente il primo elemento di tipo {@code U} se presente
    */
    public <U> Optional<U> getFirstCandidatesInAreaByType(Bounds actorBounds, Class<U> type) {
      return getCandidatesInAreaStream(actorBounds).filter(type::isInstance).map(type::cast).findFirst();
    }

    /**
    * Restituisce tutti i candidati che intersecano gli {@code actorBounds}.
    *
    * @param actorBounds bounds di riferimento
    * @return lista di candidati in area
    */
    public List<T> getCandidatesInArea(Bounds actorBounds) {
      return getCandidatesInAreaStream(actorBounds).toList();
    }

    /**
    * Restituisce il primo candidato che interseca gli {@code actorBounds}, se presente.
    *
    * @param actorBounds bounds di riferimento
    * @return Optional con il primo candidato nell'area
    */
    public Optional<T> getFirstCandidateInArea(Bounds actorBounds) {
      return getCandidatesInAreaStream(actorBounds).findFirst();
    }
  }
\end{lstlisting}
\subsubsection{Player, Enemy e StatePattern}
Il \textit{Player} e i \textit{Robot} (nemici) sono entità dinamiche che richiedono una gestione ad-hoc per le loro logiche di movimento e di interazione.
I comportamenti dipendono spesso dallo stato corrente dell'entità, ad esempio se il Player è a terra, può saltare, se è in aria non può effettuare un altro salto e subisce la gravità.
Per gestire questi stati in modo pulito e modulare, è stato adottato lo \textbf{State Pattern}.
Il Player ha una serie di stati che implementano le logiche specifiche di update e gestione degli input.
Prendiamo ad esempio la classe astratta \textbf{PlayerState}:
\begin{lstlisting}[language=Java]
public abstract class PlayerState implements State {
    protected static final Bounds NORMAL_BOUNDS = new Bounds(40, 110);
    protected final Player player;
    private static long nextId = 0;
    protected final long ID;

    public PlayerState(Player ctx) {
        this.player = ctx;
        ID = nextId++;
    }

    public void onEnter() {
    }

    public void onExit() {
    }

    @Override
    public long getID() {
        return ID;
    }

    public abstract void handleInput(Set<Action> actions, SceneContext sceneContext);

    public abstract void tick(SceneContext context, float deltaTime);

    // Gestisce l'asse orizzontale e restituisce -1 per sinistra +1 per destra
    protected int handleHorizontalInput(Set<Action> actions) {
        int x = 0;
        int s = Player.SPEED;

        if (actions.contains(Action.LEFT))
            x -= s;
        if (actions.contains(Action.RIGHT))
            x += s;

        if (x > 0) {
            player.facing = Facing.RIGHT;
        } else if (x < 0) {
            player.facing = Facing.LEFT;
        }

        player.physicsState.velocity.x = x;
        return Integer.signum(x);
    }

    protected boolean isOnGround(SceneContext context) {
        return player.isOnGround(context);
    }

    protected boolean handleDamageCollision(SceneContext context) {
        Optional<Damager> damager = context.getDamageManager().getFirstCandidateInArea(player.getDamageableBounds());
        if (damager.isPresent()) {
            switch (damager.get().getDamageType()) {
                case DamageType.FALL:
                    player.changeState(new FallDamagedPlayerState(player));
                    break;
                case DamageType.ZAP:
                default:
                    player.changeState(new DamagedPlayerState(player));
            }
            return true;
        }

        return false;
    }

    public Bounds getBounds() {
        return NORMAL_BOUNDS.anchorCenterBottom(Player.ENTITY_BOUNDS.moveCenter(player.getPosition()));
    }
}
\end{lstlisting}
La classe fornisce metodi di comodo per gestire gli input orizzontali, ma la potenzialità del pattern risiede nei metodi astratti \texttt{handleInput} e \texttt{tick}.
Questi metodi vengono implementati nelle classi concrete e rappresentano il punto d'ingresso per gestire l'update delegato allo stato corrente dell'entità.
Senza questo pattern, tutte le logiche di movimento e di reazione sarebbero concentrate in un unico metodo con lunghi blocchi di \texttt{if} o \texttt{switch} sullo stato, rendendo il codice poco estendibile.
Con gli stati, aggiungere un nuovo comportamento equivale ad aggiungere una nuova classe che implementa \texttt{PlayerState}.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{assets/player_state_uml.png}
  \caption{Schema UML semplificato dello StatePattern per la classe Player.}
\end{figure}
Analogamente, le entity nemiche utilizzano lo stesso principio, ma a differenza del Player,
il loro stato non viene alterato da input ma viene interamente gestito da una semplice IA definita all'interno degli stati.
\newpage
\subsubsection{Ascensori e Observable Pattern}
Gli ascensori sono entità che permettono al Player di spostarsi verticalmente tra i vari piani della stanza.
Per gestire il loro funzionamento, è stato adottato l'\textbf{Observer Pattern}, con una implementazione personalizzata, per scopi didattici.
E' stata così definita l'interfaccia \textbf{ObservableEntity} che espone i metodi per aggiungere, rimuovere ed eseguire dei listener, che saranno del tipo \textbf{Consumer<T>}.
\begin{lstlisting}[language=Java]
  public abstract class ObservableEntity<T> extends Entity {
    /**
     * Collezione thread-safe di listener registrati per ricevere eventi.
     */
    private final List<Consumer<T>> listeners = new CopyOnWriteArrayList<>();

    public ObservableEntity() {
        super();
    }

    public ObservableEntity(Point position) {
        super(position);
    }

    protected int getListenerCount() {
        return listeners.size();
    }

    public void addListener(Consumer<T> listener) {
        listeners.add(listener);
    }

    public void removeListener(Consumer<T> listener) {
        listeners.remove(listener);
    }

    protected void sendEvent(T value) {
        for (Consumer<T> listener : listeners) {
            listener.accept(value);
        }
    }
}
\end{lstlisting}
Gli ascensori estendono questa classe e definiscono un eventi specifici di \textbf{spostamento} e di \textbf{completamento} tramite la classe \textbf{ElevatorEvent}.

\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\parbox{0.9\linewidth}{\small
      Gli ascensori inoltre contengono una struttura denominata \textbf{StepList<T>}, un estensione di \textit{ArrayList<T>} che usa un \textbf{Comparator} per ordinare i punti in base a dei criteri prestabiliti.
      L'instanziazione nell'ascensore avviene nel seguente modo:
      \lstinline[language=Java]!StepList<Point> targets = new StepList<>(Comparator.comparingInt(Point::y))!
      I punti vengono ordinati in base alla distanza verticale da (y = 0). StepList espone inoltre un'\textbf{iteratore bidirezionale}, il perfetto cursore per muoversi tra i vari piani.
      \newline
      {\small\textsf{\textcolor{codepurple}{\textit{Si rimanda alla sezione~\ref{sec:steplist} (\textit{Struttura StepList e StepIterator}) in appendice per i dettagli implementativi.}}}}
  }}
\end{center}

Il Player, dopo aver interagito con l'ascensore, entra nello stato \textbf{ElevatorPlayerState} che lo rende immobile e riceve lo spostamento che viene effettuato dall'ascensore tramite un listener registrato.
Una volta raggiunta la destinazione, l'ascensore invia un evento di completamento al Player che esce dallo stato e riprende il controllo.
\newline
{\small\textsf{\textcolor{codepurple}{Si rimanda alla sezione~\ref{sec:elevator_player_state} in appendice per i dettagli implementativi.}}}

\subsubsection{Oggetti di scena e interazioni}
Nel gioco sono presenti degli oggetti di scena con cui il Player può interagire. Questi oggetti possono contenere degli attivabili che possono essere utilizzati al terminale,
parti di schede perforate che faranno progredire il Player nella decifratura della password oppure possono anche essere vuoti.
Gli oggetti di scena sono rappresentati dalla classe \textbf{SceneObject} che implementa l'interfaccia \texttt{Interactable}.
Essi contengono un riferimento ad un'istanza di \textbf{Collectible} che garantirà al giocatore l'oggetto corrispondente una volta terminata l'ispezione.

\subsection{Room, SceneContext e gestione delle stanze}
Il mondo di gioco è suddiviso in stanze, all'interno delle quali sono posizionate le varie entità (player, nemici, oggetti di scena, ascensori, portal ecc.).
Questa suddivisione viene gestita da un piccolo ``sistema di scene'' basato su quattro classi principali:
\begin{itemize}
  \item La classe \textbf{Map} rappresenta la mappa logica dell'intera base: è una griglia di tipi di stanza (\texttt{RoomType}) caricata da file testuale.
    Ogni cella della griglia indica se in quella posizione è presente una stanza di sinistra/destra, una stanza con uscita, oppure un blocco dell'ascensore principale.
  \item La classe \textbf{Room} rappresenta una singola stanza. Qui avviene il parsing del file di testo che definisce il layout della stanza,
    come accennato nel paragrafo~\ref{sec:map_building}: il file ASCII viene letto riga per riga e convertito in una matrice di \texttt{TileType},
    dalla quale vengono istanziate le entità (muri, pavimenti, robot, oggetti di scena ecc.).
  \item La classe \textbf{SceneContext} fornisce un contesto di esecuzione per una singola scena (stanza o sezione dell'ascensore principale),
    incapsulando i manager delle entità (\texttt{EntityManager}, \texttt{CollisionManager}, \texttt{InteractionManager}, \texttt{DamageManager})
    e gestendo in modo sicuro spawn, rimozioni e transizioni tra scene.
  \item La classe \textbf{SceneManager} mantiene il riferimento alla scena corrente e coordina il passaggio da una scena all'altra,
    delegando a \texttt{SceneContext} l'esecuzione delle operazioni di ingresso/uscita e il posizionamento del player.
\end{itemize}
\small{\textsf{\textcolor{codepurple}{Per i dettagli implementativi di Map, Room e SceneContext si rimanda alla sezione~\ref{sec:scene_system_appendix} in appendice.}}}
\newline
Il Player può spostarsi tra le stanze mediante l'entità \textbf{Portal}, uno speciale \textbf{Trigger} che implementa l'interfaccia \texttt{Interactable}.
Il \textit{Portal}, essendo un'area di trigger, non richiede un'azione esplicita da parte del giocatore per essere attivato: quando il Player entra nei suoi \texttt{Bounds},
la scena corrente richiede al \texttt{SceneManager} la transizione verso il \texttt{SceneContext} collegato.
Ogni portal contiene inoltre il \textbf{Point} dove il Player verrà posizionato una volta entrato nella nuova scena, in modo da farlo apparire nel punto corretto della stanza di destinazione.

Quando viene avviata una nuova partita, il \textbf{Model} inizializza il player e costruisce uno \textbf{SceneManager} associato ad esso.
Lo \texttt{SceneManager}, a sua volta, carica la \texttt{Map} da file testuale
(ad esempio \textbf{resources/room\_types/map.txt}),
genera tutti i \texttt{SceneContext} necessari e imposta il contesto iniziale tramite il metodo \texttt{setCurrentContext}.
Ad ogni iterazione del game loop, il metodo \texttt{updateGameState(actions, deltaTime)} del Model recupera il \texttt{SceneContext} corrente,
applica le eventuali modifiche differite (spawn e rimozioni) attraverso \texttt{updateContext()} e aggiorna le entità contenute.

Dal punto di vista del player, il ciclo di cambio stanza si può riassumere come segue:
\begin{enumerate}
  \item il Player entra nei bounds di un \textbf{Portal} nella stanza corrente;
  \item il \texttt{SceneContext} corrente registra la scena di destinazione e programmerà la transizione al prossimo \texttt{updateContext()};
  \item al frame successivo, \texttt{SceneManager.setCurrentContext} invoca \texttt{onExit} sulla scena di provenienza (notifica alle entità, rimozione del player, rilascio dei collider)
    e \texttt{onEnter} sulla scena di destinazione, calcolando lo spawn del player a partire dai portal collegati;
  \item il player viene aggiunto al nuovo \texttt{EntityManager} e, da quel momento, gli aggiornamenti del Model avvengono nella nuova scena.
\end{enumerate}

Nel caso speciale dell'ascensore principale, i vari piani dell'ascensore sono rappresentati da una serie di scene collegate in verticale nella \texttt{Map}.
Il \texttt{SceneContext} dell'ascensore mantiene una mappa tra posizioni del piano (coordinate logiche sull'albero dei piani) e scene di destinazione;
quando il player entra nello stato di utilizzo dell'ascensore, questa struttura viene utilizzata per determinare a quale stanza collegare ciascun piano.

\subsection{Update del gioco}
Ad ogni iterazione del game loop, il Model deve far 'progredire' lo stato del gioco in base al contesto, agli input ricevuti e al tempo trascorso.
Per poter consentire l'aggiornamento di tutte le entità in modo ordinato e coerente, è stato definito un flusso di aggiornamento che percorre i principali attori 'attivi' durante il game loop, dall'invocazione del metodo \texttt{updateGameState} fino alla notifica alla View.
\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth,draft=false]{assets/model_update_scheme.png}
  \caption{Flusso di aggiornamento del Model.}
\end{figure}

\subsection{Progresso di gioco}
Il progresso di gioco viene gestito tramite la classe \textbf{GameData}, contenuta da \textbf{Game} un \texttt{Singleton} che ne fornisce il riferimento.
\textit{GameData} contiene informazioni sul profilo utente corrente, i collezionabili ottenuti, la password in corso di decifrazione e il tempo di gioco trascorso.
Una volta terminata la partita, la classe è delegata al calcolo del punteggio in base alle performance del giocatore.

\subsection{Punchcard e sistema di password}
Un elemento chiave del gioco è il sistema di decifrazione della \textbf{password} tramite le schede perforate (\textbf{punchcard}).
All'avvio di ogni partita, una \textbf{password} viene pescata casualmente da un elenco predefinito e suddivisa in segmenti di 2 caratteri.
Ogni segmento corrisponde nel gioco a una scheda perforata, implementata come classe \textit{\textbf{Punchcard}},
suddivisa a sua volta in \textbf{3 frammenti}, rappresentati da \textbf{PunchCardPiece} che implementa \texttt{Collectible}.

Per rappresentare questa meccanica di gioco, è stato deciso di esplorare un approccio basato su bit e calcoli su \textbf{bitmask}.
Ogni \textbf{punchcard} è rappresentata da \textbf{3 bit}, 1 bit per ogni frammento, dove un bit settato a 1, all'interno di una variabile di tipo \texttt{int} che conterrà i frammenti recuperati, indica che il frammento è stato raccolto.
Ad esempio, con 3 frammenti si utilizzano i bit da 0 a 2 di un intero: se il giocatore ha raccolto il primo e il terzo frammento lo stato sarà \texttt{0b101} (5 in decimale).
Per ogni punchcard recuperata, una parte di \textbf{password} viene svelata al giocatore. Una volta raccolte tutte le punchcard, la password sarà completamente visibile e il giocatore potrà raggiungere la porta di uscita e terminare la partita.

\section{Struttura della View}
La View è responsabile della rappresentazione grafica del gioco e dell'interfaccia utente.
Come anticipato, è stata sviluppata utilizzando la libreria Java Swing, che fornisce componenti GUI e funzionalità di rendering 2D.

Le parti principali della View sono 2:
\begin{itemize}
  \item \textbf{Menù iniziale}: Schermata iniziale del gioco, che permette di avviare una nuova partita, caricare un profilo esistente o modificare le impostazioni.
  \item \textbf{GameView}: Schermata di rendering, responsabile del disegno del gioco.
\end{itemize}
Per la realizzazione del menù iniziale è stato utilizzato il CardLayout all'interno del JPanel principale, in modo da poter passare da una schermata all'altra in maniera pulita.

Il pannello di rendering invece estende JPanel e, all'avvio del gioco, il Controller rimuove il menù iniziale e aggiunge il pannello di rendering.
Il rendering vero e proprio avviene sovrascrivendo il metodo \texttt{paintComponent(Graphics g)}, ed è l'unico pannello che viene istanziato durante il gioco.
Tutte le entità grafiche implementano l'interfaccia \textbf{Drawable}, che espone il metodo \texttt{draw(Graphics2D g2d, float deltaTime)}.

Ogni volta che il \textbf{Model} notifica un cambiamento di stato, ovvero ad ogni iterazione del game loop (anche se non necessariamente), il metodo \texttt{repaint()}
viene chiamato sul pannello di rendering ed ogni entità disegnabile viene renderizzata a schermo.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\textwidth]{assets/view_overview.png}
  \caption{Schema semplificato rendering.}
\end{figure}

\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\parbox{0.9\linewidth}{\small
      Le entità nel \textbf{Model} contengono un ID univoco, che viene sfruttato dalla View per mantenere una mappa di \textbf{EntityView} associate alle entità,
      organizzata per \textbf{Layer} che ne determina l'ordine di rendering.
      In questo modo, ad ogni aggiornamento del gioco, la View può recuperare le istanze grafiche presenti nella scena senza doverle istanziare nuovamente, o rimuovere quelle non più presenti.
      \newline
      \lstinline[language=Java]!Map<Layer, Set<EntityView<?>>> views = Collections.synchronizedMap(new EnumMap<>(Layer.class));!
      \newline
      La mappa, come si nota dal codice, è una synchronizedMap per garantire la sicurezza in caso di accessi concorrenti, ed eliminare errori che sono stati riscontrati durante lo sviluppo.
  }}
\end{center}

\subsection{Sistema di rendering e Layer}
I layer nel gioco sono stati implementati tramite un enum \textbf{Layer}, che riassume i principali gruppi di entità grafiche presenti nel gioco.
\begin{itemize}
  \item TILE, utilizzato per pavimenti, muri ed elementi statici di sfondo
  \item INTERACTABLE, su questo layer vengono disegnati oggetti, porte e terminali
  \item ENEMIES, layer dei nemici
  \item PLAYER, layer del giocatore
  \item HUD, utilizzato per disegnare HUD e overlay a schermo
\end{itemize}
Ogni entità grafica implementa il metodo \texttt{getLayer()} che restituisce il layer di appartenenza,
in modo che la View possa organizzare l'ordine di rendering per ciascuna entità presente nella scena.

\subsection{Struttura di una EntityView}
L'\textbf{EntityView}, come \textbf{Entity} per il Model, è la classe base per tutte le entità grafiche del gioco.
E' una classe astratta generica che accetta come parametro di tipo l'entità del Model a cui è associata, contenendo il riferimento ad essa.

Le entità, a seconda del ruolo che hanno all'interno del gioco, sono rappresentate e composte in modi differenti.
Abbiamo entità statiche come muri e pavimenti, che non richiedono animazioni o cambiamenti di stato, o entità dinamiche come il Player e i nemici.
Per gestire questa varietà, ogni sottoclasse di EntityView includerà o meno istanze di \textbf{AnimationPlayer} o semplici \textbf{BufferedImage}
per rappresentare l'entità a schermo. Inoltre, alcune entità possono riprodurre suoni e saranno dotate di un'istanza di
\textbf{AudioAnimationPlayer} (se legati ad animazioni) o di \textbf{AudioPlayer}

\subsection{Gestione degli assets grafici e colori}
Considerando il gioco originale, dove ogni stanza ha una palette di colori specifica, è stato deciso di prevedere questa funzionalità anche in questa versione.
Come palette di colori, è stata utilizzata una palette ispirata al \textbf{Commodore 64}, con 16 colori distinti, inseriti nella classe \textbf{C64Color}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth,draft=false]{assets/commodore64-32x.png}
  \caption{Palette C64}
\end{figure}
Una volta definita la palette, sono state individuate le entità che richiedono una colorazione differente per stanza:
\begin{itemize}
  \item Muri e pavimenti
  \item Ascensori
  \item Background
  \item Nemici
  \item Collezionabili
\end{itemize}
Per queste entità, sono stati utilizzati degli \textbf{spritesheet} con colori speciali, dove ogni colore dello sprite viene
sostituito in fase di creazione dell'oggetto da un colore appartenente alla palette C64.
I channel utilizzati per la sostituzione sono:
\begin{itemize}
  \item Rosso: rgb(255,0,0)
  \item Magenta: rgb(255,0,255)
  \item Blu: rgb(0,0,255)
  \item Ciano: rgb(0,255,255)
  \item Verde: rgb(0,255,0)
  \item Giallo: rgb(255,255,0)
  \item Grigio: rgb(128,128,128) (channel per background)
\end{itemize}
\begin{figure}[h]
  \centering
  \colorbox{backcolour}{%
    \begin{minipage}{0.5\textwidth}
      \includegraphics[width=\textwidth,draft=false]{assets/robot.png}\\[8pt]
      \rule{0pt}{14pt}% padding bottom
    \end{minipage}%
  }
  \caption{Spritesheet con channel Robot}
\end{figure}
La sostituzione del colore viene effettuata utilizzando principalmente l'oggetto \textbf{ColorMapping}, una classe personalizzata che estende \texttt{HashMap<Color, Color>}.

Questa classe, mediante il metodo \lstinline[language=Java]!BufferedImage applyTo(BufferedImage image)! permette di mappare i canali definiti nella sua struttura dati,
che utilizza come chiave i channel da sostituire e come valore il colore che lo sostituirà.
Nel gioco sono state definite \textbf{4 istanze} di ColorMapping con palette di colori predefinite, assegnate in maniera casuale alle stanze durante l'esplorazione della base.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.3\textwidth,draft=false]{assets/colore_mapping.png}
  \caption{Channel in alto e palette utilizzate in basso.}
\end{figure}

La flessibilità di questa soluzione ha permesso di estendere questo comportamento anche alla sostituzione delle immagini rappresentanti i collezionabili.

\subsection{HUD e overlay}
Nel gioco sono presenti alcuni elementi di HUD che forniscono informazioni al giocatore:
\begin{itemize}
  \item \textbf{Overlay di ricerca}: mostra una barra di progresso che si svuota man mano che il
    giocatore avanza nella ricerca di un collezionabile all'interno di un oggetto di scena.
  \item \textbf{Menù del computer}: menù interattivo che compare quando il giocatore interagisce con un terminale.
  \item \textbf{Display del progresso di gioco}: display, visibile nelle stanze dell'ascensore, che mostra i progressi effettuati nel gioco e i collezionabili raccolti.
\end{itemize}
Questi overlay sono implementati nel Layer HUD e vengono disegnati dopo tutti gli altri elementi di gioco.
Alla base del rendering di un HUD è presente una cornice, rappresentata da un file immagine quadrato.
Questo file viene suddiviso in 9 sezioni (4 angoli, 4 lati e centro) e ridimensionato in base alle dimensioni dell'elemento da disegnare, utilizzando la classe \textbf{NineSliceRenderer}.
La classe permette inoltre di sostiuire il centro con un'immagine di sfondo personalizzata o con un colore pieno.
\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth,draft=false]{assets/nine_slice.png}
  \caption{Decorazione con tecnica Nine-Slice e utilizzo nel gioco.}
\end{figure}
\newline
Per aggiungere testi e altri elementi grafici all'interno degli HUD, è stato deciso di progettare un sistema minimale di layout piuttosto che utilizzare il sistema già presente con Java Swing,
andando a definire le seguenti classi:
\begin{itemize}
  \item \textbf{Panel}: classe contenitore degli elementi da disegnare.
  \item \textbf{PanelElement}: classe astratta base per tutti i componenti presenti all'interno di un Panel.
  \item \textbf{TextElement}: classe che estende PanelElement e rappresenta un blocco di testo.
  \item \textbf{ImageElement}: classe che estende PanelElement e definisce lo sfondo e la decorazione, contenendo un'istanza di NineSliceRenderer.
  \item \textbf{Padding}: utilizzato per rappresentare spaziature vuote tra gli elementi.
\end{itemize}
La classe \textbf{Panel} contiene due differenti layer, dinamico e statico. Il layer statico è composto da elementi che non devono essere ridisegnati nelle varie operazioni di \textit{repaint}, come ad esempio sfondi e cornici.
Il layer dinamico invece contiene elementi variabili, come ad esempio \textbf{ProgressBar}, una sottoclasse di PanelElement che mostra una barra di progresso, potenzialmente aggiornabile ad ogni render.
In questo modo, si riduce il carico di lavoro del rendering, eseguendo operazioni solo su componenti che necessitano di aggiornamenti, tramite il metodo \textbf{isDirty()} definito in PanelElement.
\subsection{Collezionabili}
I collezionabili vengono mostrati una volta che il giocatore li ha raccolti da un oggetto di scena, all'interno di un overlay dedicato.
Il collezionabile è definito da un singolo sprite, su un file png che supporta la trasparenza, e utilizzando solo il colore nero per la sostituzione con \textbf{ColorMapping}.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\textwidth,draft=false]{assets/freeze-pass.png}
  \caption{Esempio di sprite di Freeze Pass.}
\end{figure}
\newline
Un caso particolare è rappresentato dalle \textbf{punchcard}, che contengono 3 frammenti. Lo sprite delle punchcard in questo caso viene suddiviso in 3 parti, verticalmente.
Ogni frammento viene colorato per essere mostrato sull'overlay e vengono \textbf{sovrapposti} per formare l'immagine completa della punchcard, nel \textit{display di progresso del gioco}.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth,draft=false]{assets/punchcard_sprites.png}
  \caption{Sovrapposizione dei frammenti di una punchcard, da sx a dx.}
\end{figure}
\newpage
\subsection{Animazioni}
\label{sec:animations}
Le animazioni nel gioco sono create a partire da una sequenza di immagini, definite in uno \textbf{spritesheet}. Per analizzare il flusso di progettazione, prendiamo come esempio il Player.
Il Player presenta diverse animazioni, in base allo stato in cui si trova (camminata, salto, danno ecc.).
\begin{figure}[h]
  \centering
  \colorbox{codegray}{%
    \includegraphics[width=\textwidth,draft=false]{assets/player.png}
  }
  \caption{Sprite sheet del Player con animazioni.}
\end{figure}
\newline
Lo spritesheet viene suddiviso in righe, che rappresentano le diverse animazioni, e colonne, che rappresentano i frame di ogni animazione.
Ogni animazione è gestita da una classe denominata \textbf{AnimationData}, una classe immutabile (definita come \texttt{record}) che incapsula i dati principali di un'animazione:
\begin{itemize}
  \item Frames di animazione (BufferedImage[])
  \item Frame ribaltati orizzontalmente (flipped frames), utilizzati quando il Player è rivolto nella direzione opposta.
  \item Tipologia di animazione (enum \textbf{AnimationMode}: \texttt{LOOP}, \texttt{ONCE})
  \item Durata di ogni frame (in secondi)
\end{itemize}
Questi dati vengono poi utilizzati dall'istanza di \textbf{AnimationPlayer} contenuta nella \textbf{PlayerView}.
La classe \textbf{Animation} si occupa di tenere traccia del tempo trascorso e di calcolare, in base alla durata dei frame e alla modalità (\texttt{LOOP}/\texttt{ONCE}),
l'indice del frame corrente, restituendo l'immagine da disegnare (flipped o meno).
\textbf{AnimationPlayer<S>} collega questo meccanismo al pattern di stato: dato uno stato \texttt{S}, seleziona i relativi \textbf{AnimationData}, aggiorna l'animazione con il \(\Delta t\)
e notifica eventuali \textbf{AnimationListener} quando cambia il frame o lo stato dell'animazione (come avviene per \textbf{AudioAnimationPlayer} descritto nella sezione dedicata al sistema audio).
\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\parbox{0.9\linewidth}{\small
      Un caso speciale di animazione è rappresentato dall'animazione di \textbf{danno} del Player. Quando il Player subisce un danno, invece di caricare in memoria uno spritesheet,
      viene salvato l'ultimo frame disegnato e vengono applicati degli effetti sui singoli pixel, facendoli lampeggiare e rendendoli man mano trasparenti,
      in modo da simulare un effetto di \textbf{Zap} e disintegrazione, fedele al gioco originale.
      \newline
      {\small\textsf{\textcolor{codepurple}{Si rimanda alla sezione~\ref{sec:damaged_player} in appendice per i dettagli implementativi.}}}
  }}
\end{center}

\subsection{Sistema audio}
Il sistema audio del gioco ha l'obiettivo di gestire effetti sonori one-shot (come salti o `zap'),
suoni in loop (rumore di fondo dei robot, musica ambientale) e suoni sincronizzati con le animazioni.
Tutta la logica audio risiede nel package \texttt{view.audio} ed è costruita attorno a pochi componenti principali:
\begin{itemize}
  \item \textbf{ClipLoader}: utility che carica file audio dal classpath e restituisce un'istanza di \texttt{Clip} pronta alla riproduzione.
  \item \textbf{SfxData}: struttura che incapsula uno o più pool di clip, le informazioni su loop/shuffle/interruzione e fornisce il metodo \texttt{nextAvailableClip()} per recuperare una clip da riprodurre senza saturare le risorse.
  \item \textbf{AudioPlayer}: player generico che, dato un \texttt{SfxData}, riproduce effetti one-shot e loop applicando un volume globale tramite il controllo \texttt{MASTER\_GAIN} quando disponibile.
  \item \textbf{AudioAnimationPlayer}: estende \texttt{AudioPlayer} e implementa \texttt{AnimationListener}, permettendo di agganciare suoni a stati di animazione, a frame specifici e a transizioni tra stati.
  \item \textbf{AmbientAudioPlayer}: estende \texttt{AudioPlayer} e si occupa di avviare o fermare suoni ambientali in base alla presenza di certe classi di entità nel mondo di gioco.
  \item \textbf{AudioManager}: componente semplificato che consente la riproduzione veloce di file audio a partire dal percorso sul filesystem.
\end{itemize}
La classe \textbf{SfxData} rappresenta l'unità di configurazione di un effetto sonoro: partendo da uno o più file audio,
crea dei pool di clip riutilizzabili per evitare di riallocare risorse ad ogni riproduzione e per permettere multiple riproduzioni contemporanee dello stesso suono.
In alcuni casi il pool è ristretto e condiviso, per evitare la sovrapposizione di suoni,
come nel caso del pool audio riservato ai Robot, dato che possono essere presenti multiple istanze in una sola area.
contemporanee dello stesso suono.
I flag \textbf{loop}, \textbf{shuffle} e \textbf{interruptible} definiscono rispettivamente
se il suono può essere messo in loop continuo, se la scelta tra i file disponibili avviene in modo casuale (come ad esempio per gli effetti di passi) e se un effetto in corso può essere interrotto
per iniziarne uno nuovo. Il metodo \texttt{nextAvailableClip()} cerca una clip libera nel pool e, se tutte le clip sono occupate,
può eventualmente interrompere quella più vecchia se l'effetto è marcato come interrompibile.

\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\parbox{0.9\linewidth}{\small
      La classe \textbf{AudioAnimationPlayer<S>} integra il sistema audio con il sistema di animazioni: per ogni stato \texttt{S}
      è possibile registrare un suono in loop (ad esempio il ronzio di un robot mentre pattuglia), uno o più suoni sincronizzati a frame specifici (come passi o atterraggi)
      e suoni associati alle transizioni tra stati (es. ingresso nello stato di danno).
      L'implementazione si basa sulle callback \texttt{onFrameChanged} e \texttt{onStateChanged} dell'interfaccia \texttt{AnimationListener}.
      \newline
      {\small\textsf{\textcolor{codepurple}{Si rimanda alla sezione~\ref{sec:audio_system_appendix} in appendice per i dettagli implementativi del sistema audio (\texttt{SfxData}, \texttt{AudioPlayer} e \texttt{AudioAnimationPlayer}).}}}
  }}
\end{center}

La classe \textbf{AmbientAudioPlayer} collega invece l'audio al contenuto della scena corrente.
Riceve in ingresso la collezione di entità presenti (tramite il Model/View) e, per ogni classe registrata (ad esempio \texttt{Robot} o \texttt{ElectricBall}),
verifica se è presente almeno un'istanza. In caso affermativo, avvia il loop del suono associato; quando tutte le entità di quella classe scompaiono,
il loop viene fermato. In questo modo suoni ambientali come il rumore dei nemici si adattano alla situazione del gioco.
\newpage
\section{Il Gioco}
In questa sezione verrà percorso il ``journey`` del giocatore, dall'avvio del menù principale fino al completamento della partita,
illustrando le principali funzionalità implementate e le soluzioni tecniche adottate per realizzarle.

\subsection{Menù principale}
Il menù principale rappresenta il punto di ingresso dell'esperienza di gioco: tramite la schermata iniziale il giocatore può selezionare un profilo esistente,
crearne uno nuovo o modificare quello corrente, prima di avviare effettivamente la partita. La logica di coordinamento tra le varie schermate del menù
è affidata a \textbf{MenuController}, che utilizza un contenitore principale (\textbf{MainMenu}) per mostrare alternativamente la lista dei profili e l'editor.
\begin{figure}[h]
  \centering
  \begin{minipage}{0.49\textwidth}
    \includegraphics[width=\textwidth]{assets/menu-01.png}
  \end{minipage}
  \hfill
  \begin{minipage}{0.49\textwidth}
    \includegraphics[width=\textwidth]{assets/menu-02.png}
  \end{minipage}
  \caption{Schermata di selezione del profilo (sx) e schermata di creazione/modifica del profilo (dx).}
\end{figure}
La creazione del profilo avviene selezionando uno \textit{slot} libero e aprendo il pannello di editing, dove è possibile impostare il nome del giocatore
e personalizzare alcuni aspetti dell'avatar.
L'avatar è creato a partire dallo sprite base del giocatore, applicando dei simpatici copricapo.
\newline
{\small\textsf{\textcolor{codepurple}{Vedere la sezione extra~\ref{sec:extra} per maggiori dettagli e curiosità sul design degli avatar.}}}
\newline

I dati vengono memorizzati tramite \textbf{ProfileRepository} e resi disponibili alle schermate del menù
attraverso i pannelli \textbf{ProfileSelectionPanel} e \textbf{ProfileEditorPanel}, che dialogano con il \textbf{MenuController}.

\subsection{Avvio del gioco}
Una volta selezionato il profilo, il giocatore avvia la partita: il Controller chiama il metodo di inizializzazione del \textbf{Model}, caricando il profilo selezionato in una nuova istanza di \textbf{GameData}.
Successivamente viene istanziata la \textbf{GameView}, collegata come osservatore del Model,
e viene avviato il game loop descritto nella sezione~\ref{sec:game_loop} relativa al Controller, che scandisce l'aggiornamento continuo dello stato di gioco.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\textwidth]{assets/game_start.png}
  \caption{Partita avviata, si gioca!}
\end{figure}
\newpage

\subsection{Camminata, salto e motore fisico}
Il movimento del giocatore e tramite un semplice motore fisico, come definito nella sezione~\ref{sec:movement_overview} e nella sezione~\ref{sec:game_geometry}, basato sulle classi \textbf{PhysicsState}, \textbf{Force} e \textbf{Vector2}.
Ogni entità dinamica mantiene un vettore velocità e, nel caso del Player, una lista di forze attive, come gravità e impulso del salto.
La classe \textbf{PhysicsState} si occupa di sommare le forze costanti di aggiornare la velocità tenendo conto del \(\Delta t\) calcolato nel game loop,
mentre gli stati del Player (\textbf{PlayerState}) decidono quali forze applicare
in risposta ai tasti premuti (camminata a sinistra/destra, avvio di un salto) e quando azzerare o modificare lo stato fisico (ad esempio all'ingresso in un ascensore).
\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\textwidth]{assets/jump_force.png}
  \caption{Forze applicate al Player al momento del salto.}
\end{figure}
L'impulso fornisce un'accelerazione iniziale verso l'alto, che viene poi contrastata dalla forza di gravità, portando il Player a raggiungere l'apice del salto e a ricadere verso il basso.

\subsection{Gestione delle collisioni con swept AABB}
Come fa il Player a camminare senza attraversare i muri o cadere? A tale scopo è stato implementato, come già accenato nella sezione~\ref{sec:collision_system_overview} un sistema di collisione basato su aree rettangolari denominate bounding box.
I bounding box definiscono un perimetro attorno a ogni entità solida (muri, pavimenti, ascensori, nemici, player) che consente di rilevare se queste sono sovrapposte o meno.
Per lo scopo corrente, ovvero evitare che il Player attraversi enitità solide durante il movimento, bisogna evitare che le bounding box si intersechino.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.3\textwidth]{assets/bounding-box.png}
  \caption{Bounding box del Player (in blu) e dei pavimenti sottostanti (in rosso).}
\end{figure}
\newline
La gestione delle collisioni tra entità è delegata al \textbf{CollisionManager}, che utilizza un approccio basato su \textbf{swept AABB} per calcolare lo spostamento effettivo
di un'entità in movimento. A partire dai bounds correnti e dallo spostamento desiderato, il metodo \texttt{resolvedMovement} costruisce un ``broad phase'' del movimento.
Il broad phase è un rettangolo che racchiude l'area coperta dal movimento, e viene utilizzato per filtrare rapidamente le entità potenzialmente coinvolte nel movimento.
Una volta filtrati i solidi, per ciascuno, si applica l'algoritmo \texttt{sweptAABB} per trovare il punto di contatto e lo scorrimento residuo lungo la superficie.
\newline
{\small\textsf{\textcolor{codepurple}{Si rimanda alla sezione~\ref{sec:swept_aabb_appendix} in appendice per i dettagli implementativi dell'algoritmo.}}}
\newline
\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{assets/broad_phasing.png}
  \caption{Esempio di broad phasing.}
\end{figure}

\subsection{Baking dei collider statici}
Per migliorare le performance dei controlli di collisione, soprattutto per verificare rapidamente la presenza di terreno sotto il giocatore o punti di appoggio,
il \textbf{CollisionManager} supporta un passo di \textbf{baking} dei collider statici tramite il metodo \texttt{bakeStatics()}. Tutti i bounds degli oggetti che implementano
\texttt{Static} vengono caricati in una struttura \textbf{CollisionBitmap}, che permette di effettuare query veloci (ad esempio nel metodo \texttt{getGroundY} o in \texttt{maxDisplacementOnGround})
senza dover iterare ogni volta su tutte le entità solide.
\newline
{\small\textsf{\textcolor{codepurple}{Si rimanda alla sezione~\ref{sec:collision_bitmap_appendix} in appendice per i dettagli implementativi della classe \texttt{CollisionBitmap}.}}}

\subsection{Altri collider: interazioni, danni e trigger}
Oltre ai collider utilizzati per la gestione delle collisioni fisiche, esistono altri tipi di collider che permettono di gestire le interazioni tra entità.
In questi casi, l'intersecazione di bounding box è voluta ed è utilizzata per attivare eventi di gioco, come l'utilizzo dei portali,
la ricezione del danno oppure la possibilità di interagire con un oggetto.
\newpage
\subsection{Cercare collezionabili}
Lo scopo principale del gioco è raggiungere la porta d'uscita. Per farlo è necessario decifrare una password, cercando i frammenti di punchcard nascosti negli oggetti di scena della base.
Gli oggetti di scena ispezionabili (\textbf{Prop}/\textbf{SceneObject}) possono contenere diversi tipi di collezionabili oltre ai frammenti di punchcard (\textbf{PunchCardPiece}): si possono trovare
\textbf{FreezePass}, \textbf{ResetPass} che offrono dei bonus spendibili una volta utilizzato un ``terminale'' (si rimanda alla sezione successiva~\ref{sec:computer_interactions}). E' da notare però che non sempre gli oggetti di scena contengono un collezionabile!

Quando il giocatore interagisce con un oggetto di scena, verrà mostrata una barra di progresso, al termine della quale verrà rivelato il contenuto trovato. Se l'oggetto contiene un collezionabile,
il Player notifica il \textbf{GameData} tramite il metodo \texttt{collectItem}, aggiornando i contatori degli oggetti raccolti.
\begin{figure}[h]
  \centering
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.5\textwidth]{assets/fridge.png} \\
    \centering
    \includegraphics[width=0.5\textwidth]{assets/coin.png}
  \end{minipage}
  \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.62\textwidth]{assets/flask.png} \\
    \centering
    \includegraphics[width=0.62\textwidth]{assets/television.png}
  \end{minipage}
  \caption{Oggetti di scena ispezionabili}
\end{figure}
Man mano che il giocatore colleziona oggetti e frammenti di punchcard, può monitorare i progressi tramite il \textbf{display di progresso del gioco}, visibile nelle stanze dell'ascensore.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{assets/progress.png}
  \caption{Display di progresso}
\end{figure}
\newpage
\subsection{Interagire con il computer}
\label{sec:computer_interactions}
I terminali \textbf{Computer} permettono al giocatore di utilizzare i collezionabili raccolti per attivare bonus.
All'interno del gioco, esistono di due tipi bonus:
\begin{itemize}
  \item \textbf{Freeze enemies}: congela temporaneamente tutti i nemici nella stanza corrente.
  \item \textbf{Reset elevators}: riporta tutti gli ascensori della stanza alle posizioni iniziali.
\end{itemize}
\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\textwidth]{assets/using_pc.png}
  \caption{Utilizzo del terminale.}
\end{figure}
I \textbf{FreezePass} e i \textbf{ResetPass} sono collezionabili speciali che il giocatore può utilizzare per attivare i bonus di \textbf{Freeze enemies} e \textbf{Reset elevators} precedentemente elencati.
Il \textbf{GameData} tiene traccia del numero di pass disponibili e, quando uno di essi viene usato,
invoca i metodi del \textbf{SceneContext} corrente (ad esempio \texttt{freezeEnemies()} e \texttt{resetElevators()}) per congelare per qualche secondo i nemici nella stanza
o per riportare gli ascensori alle posizioni iniziali.
\subsection{Usare gli ascensori}
Gli ascensori sono una meccanica di gioco che permette l'esplorazione verticale della base: gli ascensori all'interno delle stanze, definiti nella classe (\textbf{SmallElevator}) collegano porzioni della stessa.
Gli ascensori principali, invece, collegano più stanze disposte su diversi piani nella \textbf{Map}. Quando il giocatore interagisce con un ascensore, entra nello stato \textbf{ElevatorPlayerState},
in cui il movimento è delegato all'ascensore stesso tramite eventi \textbf{ObservableEntity}, fino al raggiungimento del piano di destinazione.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.2\textwidth]{assets/small-elevators.png}
  \caption{Ascensori all'interno delle stanze.}
\end{figure}
\newpage

\subsection{Tipi di nemici: Robot e Sfere elettriche}
Nel gioco sono presenti due tipologie principali di nemici: i \textbf{Robot}, che pattugliano piattaforme orizzontali e possono, con una probabilità calcolata in fase di instanziazione, sparare un raggio elettrico (\textbf{ShockRay}),
e le \textbf{Sfere elettriche} (\textbf{ElectricBall}), che inseguono direttamente il giocatore nella stanza, ignorando ogni tipo di collisione. Entrambe le tipologie utilizzano stati
specifici per gestire il movimento (\textbf{EnemyPatrolState} e \textbf{EnemyFollowState}),
la logica di attacco e lo stato di congelamento, e condividono la stessa interfaccia di danno attraverso i rispettivi \texttt{damagerBounds}.
\begin{figure}[h]
  \centering
  \begin{minipage}{0.49\textwidth}
    \includegraphics[width=\textwidth]{assets/robot_attack.png}
  \end{minipage}
  \hfill
  \begin{minipage}{0.49\textwidth}
    \includegraphics[width=\textwidth]{assets/electric_ball.png}
  \end{minipage}
  \caption{Robot a sinistra e Sfera elettrica a destra.}
\end{figure}

\subsection{Subire danno}
Il sistema di danno si basa sulle interazioni tra entità che espongono le interfacce \texttt{Damager} e \texttt{Damageable}, gestite dai manager del Model.
Quando il Player entra in contatto con l'area di danno di un nemico, viene attivato lo stato \textbf{DamagedPlayerState},
che temporaneamente disabilita i controlli di movimento e, la View, avvia l'animazione ``electrify'' (vedere sezione ~\ref{sec:animations}).
Il \textbf{GameData} tiene traccia del numero di volte che si subiscono danni e del tempo di gioco, che influenzeranno il punteggio finale.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\textwidth]{assets/death_by_zap.png}
  \caption{ZzzZZZzZZzap!}
\end{figure}
Al termine dello stato di danno, il Player viene riposizionato al punto di spawn della stanza corrente, e la stanza viene resettata.

\subsection{Danno da caduta fuori dalla mappa}
Per gestire la caduta del giocatore oltre i limiti della stanza, ogni \textbf{Room} genera un'area di pericolo (\textbf{HazardousArea}) posizionata sotto la mappa giocabile.
Se i bounds del Player intersecano questa area, viene considerato come caduto fuori dallo schermo: il Model applica il danno corrispondente,
incrementa il contatore dei danni in \textbf{GameData} e riposiziona il giocatore al punto di spawn definito dalla stanza corrente.

\subsection{Porta di uscita}
La \textbf{porta di uscita} rappresenta l'obiettivo finale della partita: è un'entità dedicata (\textbf{ExitDoor}) posizionata in una stanza specifica della base.
L'entità fa il polling dello stato di decodifica della password tramite \textbf{GameData} verificando tramite il metodo \texttt{hasCompleteDecode()} se tutti i frammenti di punchcard sono stati raccolti.
Con la password decodificata, la porta si apre automaticamente, permettendo al giocatore di interagire con essa per completare la partita.
\begin{figure}[h]
  \centering
  \begin{minipage}{0.35\textwidth}
    \includegraphics[width=\textwidth]{assets/exit_door_closed.png}
  \end{minipage}
  \begin{minipage}{0.35\textwidth}
    \includegraphics[width=\textwidth]{assets/exit_door_open.png}
  \end{minipage}
  \caption{Porta di uscita chiusa (sx) e aperta (dx).}
\end{figure}

\subsection{Fine gioco e calcolo del punteggio}
Al termine della partita, il Model invoca \texttt{completeGame()}, che segna la partita come completata tramite \textbf{GameData} e delega il calcolo del punteggio finale.
La formula tiene conto del numero totale di oggetti raccolti, del tempo impiegato rispetto a un tempo atteso di completamento e del numero di volte che il giocatore ha subito danni,
premiando le partite rapide, con molti oggetti raccolti e con pochi danni subiti. Il profilo del giocatore viene quindi aggiornato tramite \textbf{ProfileRepository},
registrando il punteggio se è migliore del precedente, e aumentando il contatore delle vittorie.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\textwidth]{assets/end.png}
  \caption{Riepilogo del punteggio finale.}
\end{figure}

\subsection{Extra: creazione avatar ed effetto scanline}
\label{sec:extra}
Il progetto include alcune funzionalità extra, che arricchiscono l'esperienza di gioco e richiamano l'estetica del gioco originale.
\subsubsection{Scanline}
Se Java ha abilitato la proprietà \texttt{sun.java2d.opengl}, viene applicato un effetto grafico di tipo \textbf{scanline} per richiamare l'aspetto dei monitor CRT.
L'effetto è realizzato tramite il metodo \texttt{ImageEffects.createScanline}, che genera
un'overlay semi-trasparente con linee orizzontali alternante, sovrapposta al rendering della scena per simulare le righe del vecchio schermo televisivo.
Tuttavia, utilizzando la libreria Java Swing, l'effetto può causare un calo delle prestazioni, pertanto è necessario che OpenGL sia supportato e abilitato per poterne usufruire.
\begin{figure}[h]
  \centering
  \begin{minipage}{0.38\textwidth}
    \includegraphics[width=\textwidth,draft=false]{assets/scanline_off.png}
  \end{minipage}
  \begin{minipage}{0.4\textwidth}
    \includegraphics[width=\textwidth,draft=false]{assets/scanline_on.png}
  \end{minipage}
  \caption{Effetto di scanline disabilitato (sx) e abilitato (dx).}
\end{figure}

\subsubsection{Creazione avatar}
Durante la creazione del profilo, il giocatore può personalizzare il proprio avatar scegliendo tra diversi copricapo.
Le personalizzazioni sono state realizzate a partire dallo \textbf{sprite del player} andando a separare il layer del corpo da quello della testa.
La testa è stata modificata frame per frame, per comporre i vari copricapo per ogni frame delle animazioni, mantenendo comunque lo stile grafico originale. La testa viene poi sovrapposta durante
la selezione dell'avatar e passata all'interno del gioco tramite il profilo.
\begin{figure}[h]
  \centering
  \begin{minipage}{0.23\textwidth}
    \centering
    \includegraphics[width=1\textwidth]{assets/avatar-01.png} \\
    \centering
    \includegraphics[width=1\textwidth]{assets/avatar-02.png}
  \end{minipage}
  \begin{minipage}{0.23\textwidth}
    \centering
    \includegraphics[width=1\textwidth]{assets/avatar-03.png} \\
    \centering
    \includegraphics[width=1\textwidth]{assets/avatar-04.png}
  \end{minipage}
  \begin{minipage}{0.23\textwidth}
    \centering
    \includegraphics[width=1\textwidth]{assets/avatar-05.png} \\
    \centering
    \includegraphics[width=1\textwidth]{assets/avatar-06.png}
  \end{minipage}
  \begin{minipage}{0.23\textwidth}
    \centering
    \includegraphics[width=1\textwidth]{assets/avatar-07.png} \\
    \centering
    \includegraphics[width=1\textwidth]{assets/avatar-08.png}
  \end{minipage}
  \caption{Avatar disponibili! Alcuni sono molto familiari...}
\end{figure}
\newpage
\section{Conclusioni}
Il progetto ha rappresentato una sfida interessante, che ha messo in luce i principali problemi legati allo sviluppo del software, e le soluzioni che possono essere applicate caso per caso.

La realizzazione di un videogioco, anche in scala didattica, evidenzia
come aspetti apparentemente indipendenti (input, aggiornamento temporale, fisica, collisioni, rendering e gestione delle risorse)
debbano invece essere progettati in modo coerente, per mantenere comportamento deterministico e controlli responsivi.

A tale scopo, l'adozione del pattern MVC ha avuto un ruolo centrale nel mantenere la separazione tra logica di gioco e interfacce, contribuendo a mantenere il progetto organizzato nonostante la moltitudine di classi gestite.

Inoltre, pattern come \textbf{State}, hanno facilitato di molto la gestione di comportamenti complessi, separando e
isolando logiche che altrimenti sarebbero state inserite come lunghe porzioni di codice poco manutenibile e
difficilmente estendibile.

Durante lo sviluppo di gioco, è stato fondamentale individuare quali parti del software potevano impattare maggiormente sulle performance del gioco.
In particolare, è stata prestata attenzione alla gestione delle collisioni, con ottimizzazione come baking di collider statici e filtraggio con broad phase,
che hanno permesso di ottenere un'esperienza di gioco fluida anche in presenza di una moltitudine di entità in scena.

Applicare i principi della programmazione orientata ad oggetti, per questa tipologia di progetto, ha facilitato la creazione e la
modellazione di entità di gioco complosse, avvalendosi di concetti come astrazione e composizione. Le varie meccaniche di gioco sono
state scomposte e analizzate singolarmente, per poi essere implementate come componenti, sottoclassi o interfacce. Questo processo di sviluppo
ha permesso di creare un software che all'apparenza sembrava molto difficile da realizzare, ma che grazie a un'attenta progettazione
si è rivelato gestibile e divertente da sviluppare.

\newpage
\appendix
\section{Appendice}
Dettagli tecnici aggiuntivi.

\subsection{Sistema audio: SfxData e AudioAnimationPlayer}
\label{sec:audio_system_appendix}
In questa sezione sono raccolti i dettagli implementativi principali del sistema audio.
\textbf{SfxData} si occupa di creare e gestire i pool di clip a partire dai file audio di risorsa, mentre \textbf{AudioAnimationPlayer}
coordina gli eventi audio con gli stati e i frame delle animazioni.

Di seguito si riporta la parte principale dell'implementazione di \texttt{SfxData}, relativa alla creazione dei pool e alla scelta della clip successiva:

\begin{lstlisting}[language=Java]
public class SfxData {
  private final List<List<Clip>> soundPools;
  private final boolean loop;
  private final boolean shuffle;
  private final boolean interruptible;

  private int currentPoolIdx;

  private final Random random = new Random();

  private SfxData(List<List<Clip>> soundPools, boolean loop, boolean shuffle, boolean interruptible) {
    this.soundPools = soundPools;
    this.loop = loop;
    this.shuffle = shuffle;
    this.interruptible = interruptible;
  }

  public static SfxData fromFiles(boolean loop, boolean shuffle, boolean interruptible, int poolSize,
                  String... filenames) {
    List<List<Clip>> allPools = new ArrayList<>();

    for (String filename : filenames) {
      List<Clip> clipPool = new ArrayList<>();
      for (int i = 0; i < poolSize; i++) {
        Clip clip = ClipLoader.load(filename);
        clipPool.add(clip);
      }
      if (!clipPool.isEmpty()) {
        allPools.add(clipPool);
      }
    }
    return new SfxData(allPools, loop, shuffle, interruptible);
  }

  public Clip nextAvailableClip() {
    if (soundPools.isEmpty())
      return null;

    if (shuffle && soundPools.size() > 1) {
      currentPoolIdx = random.nextInt(soundPools.size());
    } else {
      currentPoolIdx = (currentPoolIdx + 1) % soundPools.size();
    }
    List<Clip> selectedPool = soundPools.get(currentPoolIdx);

    if (selectedPool.isEmpty())
      return null;

    for (Clip clip : selectedPool) {
      if (!clip.isRunning()) {
        return clip;
      }
    }

    Clip forcedClip = selectedPool.getFirst();
    if (isInterruptible()) {
      forcedClip.stop();
      forcedClip.setFramePosition(0);
    }
    return forcedClip;
  }

  public boolean isLoop() {
    return loop;
  }

  public boolean isInterruptible() {
    return interruptible;
  }
}
\end{lstlisting}

Per quanto riguarda l'integrazione con il sistema di animazioni, la classe \textbf{AudioAnimationPlayer} reagisce ai cambi di frame e di stato
tramite i metodi \texttt{onFrameChanged} e \texttt{onStateChanged} mostrati di seguito:

\begin{lstlisting}[language=Java]
public class AudioAnimationPlayer<S extends State> extends AudioPlayer
    implements AnimationListener<S> {

  private final Map<Class<? extends S>, SfxData> stateLoopSounds = new HashMap<>();
  private final Map<Class<? extends S>, Map<Integer, SfxData>> frameSounds = new HashMap<>();
  private final Map<Class<? extends S>, Map<Class<? extends S>, SfxData>> transitionSounds = new HashMap<>();

  private Class<? extends State> lastStateClass;
  private int lastFrameIndex = -1;

  @Override
  public void onFrameChanged(S state, int frameIndex) {
    if (state == null)
      return;

    if (state.getClass().equals(lastStateClass) && lastFrameIndex == frameIndex)
      return;

    lastStateClass = state.getClass();
    lastFrameIndex = frameIndex;

    Class<? extends State> stateClass = state.getClass();
    Map<Integer, SfxData> framesMap = frameSounds.get(stateClass);

    if (framesMap != null) {
      SfxData frameData = framesMap.get(frameIndex);
      if (frameData != null) {
        playOneShot(frameData);
      }
    }
  }

  @Override
  public void onStateChanged(S oldState, S newState) {
    stopCurrentLoop();

    if (newState == null)
      return;

    Class<? extends State> newClass = newState.getClass();
    SfxData loopData = stateLoopSounds.get(newClass);

    if (loopData != null && loopData.isLoop()) {
      playLoop(loopData);
    }

    if (oldState == null)
      return;

    SfxData sfx = null;

    if (!oldState.getClass().equals(newState.getClass())) {
      var fromAnyTransition = transitionSounds.get(null);
      if (fromAnyTransition != null) {
        var sound = fromAnyTransition.get(newState.getClass());
        if (sound != null)
          sfx = sound;
      }

      var toAnyTransition = transitionSounds.get(oldState.getClass());
      if (toAnyTransition != null) {
        var sound = toAnyTransition.get(null);
        if (sound != null)
          sfx = sound;
      }
    }

    var transition = transitionSounds.get(oldState.getClass());
    if (transition != null) {
      var sound = transition.get(newState.getClass());
      if (sound != null)
        sfx = sound;
    }

    if (sfx != null)
      playOneShot(sfx);
  }
}
\end{lstlisting}
\subsection{Sistema di scene: Map, Room, SceneManager e SceneContext}
\label{sec:scene_system_appendix}
In questa sezione sono raccolti i dettagli principali dell'implementazione del sistema di scene,
che collega la mappa logica della base (\texttt{Map}), i layout delle stanze (\texttt{Room}) e la gestione del contesto di gioco (\texttt{SceneManager} e \texttt{SceneContext}).

La classe \textbf{Map} carica da file una rappresentazione testuale della base, in cui ogni carattere rappresenta un tipo di stanza (vuota, normale, con uscita, ascensore ecc.):

  \begin{lstlisting}[language=Java]
  public class Map {
    private static final int WORLD_WIDTH = 8;
    private static final int WORLD_HEIGHT = 5;

    /** Matrice di tipi di stanza che rappresenta la mappa. */
    private final RoomType[][] rooms;

    public static Map fromFile(String filePath) throws IOException {
      RoomType[][] map = createEmptyRooms();
      try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
        String line;
        int row = 0;
        while ((line = br.readLine()) != null && row < WORLD_HEIGHT) {
          line = line.replace(" ", "");
          for (int col = 0; col < Math.min(line.length(), WORLD_WIDTH); col++) {
            map[row][col] = RoomType.fromChar(line.charAt(col));
          }
          row++;
        }
      }
      return new Map(map);
    }
  }
  \end{lstlisting}

Il metodo \texttt{generateScenes(SceneManager)} di \textbf{Map} scorre questa matrice e, per ogni cella non vuota, costruisce un \texttt{SceneBuilder} a partire da un file di stanza
oppure da una colonna dell'ascensore principale, collegando tra loro le scene adiacenti tramite portal e registrando le destinazioni dei piani dell'ascensore.

La classe \textbf{Room} gestisce invece il parsing del layout ASCII di una singola stanza e la generazione delle entità corrispondenti:

  \begin{lstlisting}[language=Java]
  public class Room {
    public static Room fromFile(String filePath, int mapWidth, int mapHeight) throws IOException {
      TileType[][] map = initializeMap(mapWidth, mapHeight);
      try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
        String line;
        int row = 0;
        while ((line = br.readLine()) != null && row < mapHeight) {
          line = line.replace(" ", "");
          for (int col = 0; col < Math.min(line.length(), mapWidth); col++) {
            map[row][col] = TileType.fromChar(line.charAt(col));
          }
          row++;
        }
      }
      return new Room(map, filePath);
    }

    public List<Entity> generateEntities() {
      List<Entity> res = new ArrayList<>();
      boolean[][] processedPortals = new boolean[mapHeight][mapWidth];

      for (int y = 0; y < mapHeight; y++) {
        for (int x = 0; x < mapWidth; x++) {
          switch (map[y][x]) {
            case TileType.WALL -> res.add(new Wall(indexToWorldPoint(x, y, TILE_SIZE)));
            case TileType.FLOOR -> res.add(new Floor(indexToWorldPoint(x, y, TILE_SIZE)));
            case TileType.ENEMY_ROBOT -> res.add(new Robot(indexToWorldPoint(x, y, ENTITY_SIZE, 0, 8)));
            // ... altri casi per nemici, portal, ascensori, oggetti di scena, uscita ...
          }
        }
      }

      // Area per danneggiare il player quando cade fuori dalla mappa
      res.add(new HazardousArea(new Bounds(-1000, 1200, 2000, 1300)));
      return res;
    }
  }
  \end{lstlisting}

Una volta costruite le scene, lo \textbf{SceneManager} viene inizializzato passando il \texttt{Player} principale e caricando la mappa:

  \begin{lstlisting}[language=Java]
  public class SceneManager {
    private final List<SceneContext> scenes;
    private SceneContext currentContext;
    private final Player player;

    public SceneManager(Player player) {
      Map map;
      try {
        map = Map.fromFile("resources/room_types/map.txt");
      } catch (IOException e) {
        throw new RuntimeException(e);
      }

      scenes = map.generateScenes(this);
      this.player = player;
      setCurrentContext(scenes.get(0));
    }

    public void setCurrentContext(SceneContext sceneContext) {
      if (currentContext != null) {
        currentContext.onExit(player);
      }

      SceneContext from = currentContext;
      currentContext = sceneContext;
      currentContext.onEnter(player, from);
    }
  }
  \end{lstlisting}

Il metodo \texttt{setCurrentContext} incapsula il ciclo di vita di cambio scena: prima notifica l'uscita dalla scena corrente (\texttt{onExit}),
poi attiva la scena successiva invocando \texttt{onEnter} e passando il player e la scena di provenienza, così da poter calcolare correttamente lo spawn.

Infine, la classe \textbf{SceneContext} rappresenta il vero e proprio ``contenitore logico'' di una scena, con i suoi manager e le code per spawn/rimozione sicuri:

  \begin{lstlisting}[language=Java]
  public class SceneContext {
    private final SceneManager sceneManager;
    private final EntityManager entityManager;
    private final CollisionManager collisionManager;
    private final InteractionManager interactionManager;
    private final DamageManager damageManager;

    private final List<Entity> toRemove = new ArrayList<>();
    private final List<Entity> toAdd = new ArrayList<>();

    private SceneContext nextScene = null;
    private Map<SceneContext, Portal> scenePortal;

    public void updateContext() {
      toAdd.forEach(entityManager::add);
      toAdd.clear();
      toRemove.forEach(entityManager::remove);
      toRemove.clear();
      if (this.nextScene != null) {
        sceneManager.setCurrentContext(nextScene);
        this.nextScene = null;
      }
    }

    public void onEnter(Player player, SceneContext fromScene) {
      if (!scenePortal.isEmpty()) {
        Portal p = scenePortal.getOrDefault(fromScene, entityManager.getPortals().getFirst());
        Point spawnPosition = p != null
          ? p.getSpawnPosition(player.getEntityBounds())
          : new Point(100, 400);
        player.onRoomEnter(spawnPosition);
      }

      entityManager.add(player);
      bakeColliders();
    }

    public void onExit(Player player) {
      entityManager.getEntities().forEach(Entity::onRoomLeave);
      removeEntity(player);
      releaseColliders();
    }
  }
  \end{lstlisting}

In questo modo il Model, ad ogni chiamata a \texttt{updateGameState}, può lavorare sempre e solo sul \texttt{SceneContext} corrente,
senza dover conoscere i dettagli delle transizioni o della struttura complessiva della mappa.

\subsection{Struttura StepList e StepIterator}
\label{sec:steplist}
La struttura \texttt{StepList<T>} viene utilizzata per gestire una lista ordinata di elementi in base a un \texttt{Comparator} fornito in fase di costruzione e per navigare comodamente tra gli elementi tramite un iteratore bidirezionale specializzato (\texttt{StepIterator}).

La classe mantiene gli elementi sempre ordinati sovrascrivendo il metodo \texttt{add}, che inserisce il nuovo elemento nella posizione corretta secondo il comparatore. L'iteratore interno \texttt{StepIterator} espone operazioni di spostamento avanti/indietro e permette di posizionare il cursore su un elemento esistente.

Di seguito si riporta l'implementazione completa:

\begin{lstlisting}[language=Java]
/**
 * Lista che ordina gli elementi secondo un {@link Comparator} fornito.
 * Fornisce un iteratore bidirezionale ({@link StepIterator}) per la navigazione nella lista.
 * Utile per logiche di gioco che riguardano il posizionamento degli ascensori.
 *
 * @param <T> tipo degli elementi nella lista
 */
public class StepList<T> extends ArrayList<T> {
  private final Comparator<? super T> comparator;

  /**
   * Costruisce una nuova {@code StepList} usando il comparatore specificato.
   *
   * @param comparator comparatore per l'ordinamento degli elementi
   */
  public StepList(Comparator<? super T> comparator) {
    super();
    this.comparator = comparator;
  }

  /**
   * Aggiunge l'elemento nella posizione secondo il comparatore.
   * Sovrascrive il comportamento di {@link ArrayList#add(Object)}.
   *
   * @param element elemento da aggiungere
   * @return sempre {@code true}
   */
  @Override
  public boolean add(T element) {
    int index = 0;
    for (; index < size(); index++) {
      if (comparator.compare(element, get(index)) < 0) {
        break;
      }
    }

    super.add(index, element);
    return true;
  }

  /**
   * Restituisce un iteratore bidirezionale specializzato ({@link StepIterator})
   * che mantiene un cursore interno e permette di spostarsi avanti/indietro.
   *
   * @return nuovo {@link StepIterator}
   */
  @Override
  public StepIterator iterator() {
    return new StepIterator();
  }

  /**
   * Iteratore interno per {@link StepList} che espone operazioni forward/backward
   * e la possibilita' di posizionare il cursore su un elemento.
   */
  public class StepIterator implements Iterator<T> {
    private int cursor = 0;

    /**
     * Indica se esiste un elemento successivo rispetto al cursore.
     *
     * @return {@code true} se c'e' un elemento successivo
     */
    public boolean hasNext() {
      return cursor < size();
    }

    /**
     * Restituisce l'elemento corrente e avanza il cursore.
     *
     * @return elemento successivo
     * @throws NoSuchElementException se non ci sono elementi successivi
     */
    public T next() {
      if (!hasNext())
        throw new NoSuchElementException();
      return get(cursor++);
    }

    /**
     * Indica se esiste un elemento precedente rispetto al cursore.
     *
     * @return {@code true} se c'e' un elemento precedente
     */
    public boolean hasPrevious() {
      return cursor > 0;
    }

    /**
     * Sposta indietro il cursore e restituisce l'elemento precedente.
     *
     * @return elemento precedente
     * @throws NoSuchElementException se non ci sono elementi precedenti
     */
    public T previous() {
      if (!hasPrevious())
        throw new NoSuchElementException();
      return get(--cursor);
    }

    /**
     * Posiziona il cursore sull'elemento specificato se presente nella lista.
     *
     * @param element elemento su cui posizionare il cursore
     * @return {@code true} se l'elemento e' stato trovato e il cursore aggiornato, {@code false} altrimenti
     */
    public boolean setCursorAt(T element) {
      int index = indexOf(element);
      if (index < 0)
        return false;
      cursor = index;
      return true;
    }
  }
}
\end{lstlisting}

\subsection{CollisionBitmap e baking dei collider statici}
\label{sec:collision_bitmap_appendix}
In questa sezione sono riportati i dettagli implementativi principali relativi al \textbf{baking} dei collider statici
e all'uso della struttura \textbf{CollisionBitmap} da parte del \textbf{CollisionManager}, come descritto nella sezione dedicata alle meccaniche di gioco.

La classe \textbf{CollisionBitmap} implementa una bitmap bidimensionale compatta, in cui ogni bit rappresenta la presenza o assenza
di un punto solido nello spazio di gioco. Per motivi di efficienza, la griglia viene "sdraiata" in un array monodimensionale di \texttt{long},
in modo da poter effettuare set/get di singoli punti usando semplici operazioni di bit shifting:

\begin{lstlisting}[language=Java]
public class CollisionBitmap {
  private final int H = 800;
  private final int W = 1280;
  // Ogni long contiene 64 bit; la bitmap e' quindi W*H bit complessivi
  private final long[] bits = new long[(int) Math.ceil((double) (H * W) / 64)];

  private void set(int x, int y) {
    if (x < 0 || y < 0 || x >= W || y >= H)
      return;

    int fullIndex = y * W + x;      // indice assoluto nel piano
    int idx = fullIndex >> 6;       // indice nell'array (equivale a / 64)
    int position = fullIndex & 63;  // posizione nel long (equivale a % 64)
    bits[idx] |= (1L << position);  // accende il bit corrispondente
  }

  public boolean get(int x, int y) {
    if (x < 0 || y < 0 || x >= W || y >= H)
      return false;

    int fullIndex = y * W + x;
    int idx = fullIndex >> 6;
    int position = fullIndex & 63;
    // Controlla se il bit e' presente
    return (bits[idx] & (1L << position)) != 0;
  }

  public void loadBounds(Bounds bounds) {
    int x1 = Math.max(0, bounds.left());
    int y1 = Math.max(0, bounds.top());

    int x2 = Math.min(W - 1, x1 + bounds.width());
    int y2 = Math.min(H - 1, y1 + bounds.height());

    for (int y = y1; y <= y2; y++) {
      for (int x = x1; x <= x2; x++) {
        set(x, y);
      }
    }
  }
}
\end{lstlisting}

Il \textbf{CollisionManager} utilizza questa bitmap per fare "baking" in anticipo i collider statici, caricando i bounds di tutte le entita' che implementano \texttt{Static}
e sfruttando poi query rapide (ad esempio per verificare la presenza di terreno o il massimo spostamento orizzontale consentito):

\begin{lstlisting}[language=Java]
public class CollisionManager {
  private final EntityManager entityManager;
  private CollisionBitmap collisionBitmap;

  public void bakeStatics() {
    collisionBitmap = new CollisionBitmap();
    getSolids().stream()
      .filter(solid -> solid instanceof Static)
      .forEach(solid -> collisionBitmap.loadBounds(solid.getBounds()));
  }

  private boolean isPointColliding(Point p) {
    return collisionBitmap.get(p);
  }

  public Point maxDisplacementOnGround(Bounds current, Point mov) {
    int desiredHorizontal = mov.x();
    int direction = Integer.signum(desiredHorizontal);
    if (direction == 0) {
      return new Point(0, mov.y());
    }

    Point start = (direction > 0
      ? current.bottomRight()
      : current.bottomLeft()).add(0, 1);

    int maxDisplacement = 0;
    for (int step = 1; step <= Math.abs(desiredHorizontal); step++) {
      Point testPoint = start.add(direction * step, 0);
      if (!isPointColliding(testPoint)) {
        break;
      }
      maxDisplacement = step;
    }
    return new Point(maxDisplacement * direction, mov.y());
  }
}
\end{lstlisting}
In questo modo, le operazioni piu' frequenti legate al controllo del terreno possono evitare di iterare ogni volta su tutti i collider solidi,
delegando il lavoro a semplici accessi alla bitmap in memoria.

\subsection{Algoritmo swept AABB nel CollisionManager}
\label{sec:swept_aabb_appendix}
In questa sezione vengono riportati i dettagli implementativi dell'algoritmo di \textbf{swept AABB} utilizzato dal \textbf{CollisionManager}
per calcolare il movimento di un'entita' in presenza di ostacoli rettangolari allineati agli assi.

Per lo studio teorico della tecnica e delle formule di base è stato fatto riferimento del sito web Amanotes \textbf{\href{https://www.amanotes.com/post/using-swept-aabb-to-detect-and-process-collision}{Using swept AABB to detect and process collision}}.

L'idea di base e' la seguente: dato un rettangolo (il bounding box dell'entità) e uno spostamento desiderato $\Delta x, \Delta y$,
si considera il movimento come una traiettoria continua nel tempo $t$. Per ogni ostacolo rettangolare si calcolano i tempi di ``entrata''
e ``uscita'' dalla collisione lungo ciascun asse, e si determina il primo istante in cui avviene la collisione.

La funzione \texttt{resolvedMovement} del \textbf{CollisionManager} costruisce il \emph{broad phase} del movimento, un rettangolo che contiene
l'area coperta dallo spostamento, e filtra i soli collider che intersecano questo rettangolo. Per ciascuno di essi viene poi chiamato il metodo privato
\texttt{sweptAABB}, che implementa il test di collisione e restituisce lo spostamento risolto:

\begin{lstlisting}[language=Java]
private Point sweptAABB(Bounds current, Point mov, Bounds other) {
  float dxEntry, dxExit; // distanze di entrata/uscita sull'asse X
  float dyEntry, dyExit; // distanze di entrata/uscita sull'asse Y

  if (mov.x() > 0) {
    dxEntry = other.left() - current.right();
    dxExit = other.right() - current.left();
  } else {
    dxEntry = other.right() - current.left();
    dxExit = other.left() - current.right();
  }

  if (mov.y() > 0) {
    dyEntry = other.top() - current.bottom();
    dyExit = other.bottom() - current.top();
  } else {
    dyEntry = other.bottom() - current.top();
    dyExit = other.top() - current.bottom();
  }

  float txEntry = (mov.x() == 0) ? Float.NEGATIVE_INFINITY : dxEntry / mov.x();
  float txExit  = (mov.x() == 0) ? Float.POSITIVE_INFINITY : dxExit  / mov.x();
  float tyEntry = (mov.y() == 0) ? Float.NEGATIVE_INFINITY : dyEntry / mov.y();
  float tyExit  = (mov.y() == 0) ? Float.POSITIVE_INFINITY : dyExit  / mov.y();

  float entryTime = Math.max(txEntry, tyEntry); // primo istante di collisione
  float exitTime  = Math.min(txExit, tyExit);   // istante di uscita dalla collisione

  // Se non esiste un intervallo di tempo valido, non c'e' collisione
  if (entryTime > exitTime || entryTime < 0.0f || entryTime > 1.0f) {
    return mov;
  }

  // Movimento fino al punto di contatto
  float moveToContactX = mov.x() * entryTime;
  float moveToContactY = mov.y() * entryTime;

  float remainingTime = 1.0f - entryTime;
  float slideX = 0, slideY = 0;

  // Scorrimento lungo la superficie: si annulla la componente
  // dell'asse su cui avviene per prima la collisione
  if (txEntry > tyEntry) {
    // collisione su X, si lascia scorrere su Y
    slideY = mov.y() * remainingTime;
  } else {
    // collisione su Y, si lascia scorrere su X
    slideX = mov.x() * remainingTime;
  }

  return new Point(
    (int) (moveToContactX + slideX),
    (int) (moveToContactY + slideY)
  );
}
\end{lstlisting}

In questo modo il movimento risultante porta l'entità fino al primo punto di contatto con l'ostacolo ottenendo un comportamento privo di penetrazioni visibili tra i collider.

\subsection{ElevatorPlayerState}
\label{sec:elevator_player_state}
Codice completo della gestione dello stato del Player durante l'utilizzo di un ascensore.
\begin{lstlisting}[language=Java]
  public class ElevatorPlayerState extends PlayerState {
    private final Consumer<ElevatorEvent> elevatorEventConsumer = event -> {
        switch (event.type()) {
            case POSITION -> acceptDisplacement(event.point());
            case FINISH -> player.changeState(new IdlePlayerState(player));
            default -> {
            }
        }
    };

    private final ObservableEntity<ElevatorEvent> observable;
    private final Runnable onEnter;

    public ElevatorPlayerState(Player ctx, ObservableEntity<ElevatorEvent> elevator, Runnable onEnter) {
        super(ctx);
        this.observable = elevator;
        this.onEnter = onEnter;
    }

    /**
     * Applica lo spostamento fornito dall'evento dell'ascensore.
     *
     * @param p delta della posizione
     */
    private void acceptDisplacement(Point p) {
        player.translate(p);
    }

    /**
     * All'ingresso si annulla la fisica del player, ci si sottoscrive agli eventi
     * e si invoca l'azione di salita/discesa fornita dall'ascensore.
     */
    @Override
    public void onEnter() {
        player.physicsState.clearState();
        // Si ascoltano gli eventi di movimento/terminazione dell'ascensore
        observable.addListener(elevatorEventConsumer);
        onEnter.run();
    }

    /**
     * Al termine si ripristina la gravita e si rimuove il listener.
     */
    @Override
    public void onExit() {
        player.physicsState.forces.add(Player.GRAVITY);
        observable.removeListener(elevatorEventConsumer);
    }

    @Override
    public void handleInput(Set<Action> actions, SceneContext sceneContext) {
        handleDamageCollision(sceneContext);
    }

    @Override
    public void tick(SceneContext context, float deltaTime) {
    }
}
\end{lstlisting}

\subsection{DamagedPlayerState e animazione "electrify"}
\label{sec:damaged_player}
In questa sezione si illustra la gestione dello stato di player danneggiato (\texttt{DamagedPlayerState}) e la relativa animazione ``electrify''.
Quando il player subisce danno, viene attivata un'animazione che alterna variazioni di luminosità, rimozione progressiva di pixel e rotazione dei colori per un effetto lampeggiante. Di seguito sono riportati i segmenti di codice rilevanti:

\paragraph{Factory dell'animazione ``electrify''}
\begin{lstlisting}[language=Java]
/**
 * Factory di animazioni raster derivate da immagini.
 * Fornisce metodi helper per creare animazioni applicando
 * effetti visivi alle immagini di input.
 */
public class AnimationFactory {
  /**
   * Crea un'animazione "electrify" a partire da un'immagine di base.
   * L'animazione è composta da una sequenza di frame che alternano
   * variazioni di luminosità, rimozione progressiva di pixel e rotazione
   * dei colori per un effetto lampeggiante.
   *
   * @param img           immagine di partenza (non viene modificata)
   * @param totalDuration durata totale dell'animazione in secondi
   * @return {@link AnimationData} contenente i frame e la durata di ciascun frame
   */
  public static AnimationData createElectrifyAnimation(BufferedImage img, float totalDuration) {
    int totalFrames = 80;
    float frameDuration = totalDuration / totalFrames;

    BufferedImage[] frames = new BufferedImage[totalFrames];

    for (int i = 0; i < totalFrames; i++) {
      BufferedImage frame = copyImage(img);

      // Alterna colori scuri e chiari
      if (i % 2 == 0) {
        frame = ImageEffects.darken(frame, 0.6);
      } else {
        frame = ImageEffects.lighten(frame, 0.6);
      }

      if (i >= 40) {
        // rimuovi pixel progressivamente
        int pixelsToRemove = (i - 40 + 1) * 120;
        frame = ImageEffects.removePixels(frame, pixelsToRemove);
      }

      // inverti ogni 2 frame
      if ((i / 2) % 2 == 1) {
        frame = ImageEffects.rotateColors(frame);
      }

      frames[i] = frame;
    }

    return new AnimationData(frames, frames, AnimationMode.ONCE, frameDuration);
  }

  /**
   * Crea e restituisce una copia profonda dell'immagine fornita.
   * Utilizzato per non modificare l'immagine originale durante la
   * generazione dei frame.
   *
   * @param img immagine da copiare
   * @return nuova istanza di {@link BufferedImage} con gli stessi dati
   */
  private static BufferedImage copyImage(BufferedImage img) {
    BufferedImage copy = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_INT_ARGB);
    copy.setData(img.getData());
    return copy;
  }
}
\end{lstlisting}

\paragraph{Attivazione dell'animazione in draw}
\begin{lstlisting}[language=Java]
public void draw(Graphics2D g, float deltaTime) {
  PlayerState playerState = entity.getState();

  if (playerState instanceof DamagedPlayerState) {
    if (!animationDataMap.containsKey(DamagedPlayerState.class)) {
      // Basta aggiungere l'animazione all'HashMap, la lambda passata all'AnimationPlayer la recupererà
      animationDataMap.put(DamagedPlayerState.class, AnimationFactory.createElectrifyAnimation(lastFrame,
          DamagedPlayerState.DURATION));
    }
  } else
    animationDataMap.remove(DamagedPlayerState.class);
  // ...
}
\end{lstlisting}
In questo modo, quando il player entra nello stato danneggiato, viene creata e attivata l'animazione ``electrify''.

\end{document}
