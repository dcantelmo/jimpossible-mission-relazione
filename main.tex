\documentclass[11pt,a4paper]{article}
% Language and encoding
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}

\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.9]{beramono} % Un font monospaziato molto più bello

% Common packages
\usepackage{lmodern}
% Font leggibile a schermo
\usepackage[sfdefault,light,scaled=0.95]{FiraSans} % light weight for body text
\usepackage{FiraMono}
% Font matematico armonizzato
\usepackage{newtxmath}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{hyperref}
\hypersetup{hidelinks} % rimuove contorni colorati dai link (indice, riferimenti)
\usepackage{csquotes}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{forest}
\usepackage{listings}
% Definizione colori "Flat" moderni
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.96} % Grigio chiarissimo, quasi bianco
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}

\lstset{
  language=Java,
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegray}\itshape, % Commenti in italico
  keywordstyle=\color{codepurple}\bfseries,
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codegreen},
  basicstyle=\fontsize{9}{11}\selectfont\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  frame=none, % Rimuove la cornice completa vecchia scuola
  framexleftmargin=5mm, % Margine per la linea laterale
  xleftmargin=5mm,
  % Aggiunge una barra laterale colorata moderna invece del box
  framesep=5pt,
  rulecolor=\color{codepurple}, % Colore della barra laterale
  framerule=2pt, % Spessore barra laterale
  frame=l % Solo linea a sinistra
}

% Page geometry
\geometry{margin=2.5cm}

% Metadata
\title{{\Huge Progetto: JImpossible Mission}}
\author{Daniele Cantelmo\\Matricola 1815100\\Teledidattica}
\date{Corso di Metodologie di Programmazione\\\today}

\begin{document}
\maketitle
\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{assets/main.jpg}
\end{figure}
\newpage
\tableofcontents
\newpage

\section{Introduzione}
Il documento descrive il progetto \textbf{JImpossible Mission}, un progetto didattico che consiste nella realizzazione di un videogioco
in Java basata sul classico gioco per Commodore 64 "Impossible Mission".
\newline
\newline
Il videogioco è un platform 2D in cui il giocatore controlla un agente segreto infiltrato in una base nemica.
Lo scopo del giocatore è quello di cercare e raccogliere, all'interno della base, tutti i frammenti di schede perforate disperse
e nascoste all'interno degli oggetti discena. Una volta raccolti tutti i frammenti sarà possibile decifrare il codice di accesso alla
stanza di controllo e terminare la missione una volta raggiunta la porta.
\newline
\newline
Il gioco presenta varie meccaniche fondamentali, che definiscono il modo in cui il giocatore interagisce con l'ambiente di gioco e le sfide che deve affrontare.
Tra queste meccaniche principali troviamo:
\begin{itemize}
  \item Controllo del personaggio principale tramite tastiera
  \item Nemici con IA
  \item Interazione con oggetti collezionabili e dispositivi (PC, ascensori)
  \item Gestione delle collisioni tra entità
  \item Ascensori
  \item Suoni e animazioni
\end{itemize}
Il gioco è stato sviluppato utilizzando Java, con versione di riferimento JDK 22.
Per la gestione dei menù, della grafica e delle animazioni è stata utilizzata la libreria Java Swing

I requisiti funzionali del progetto riguardano principalmente:
\begin{itemize}
  \item Impiego del pattern strutturale MVC (Model-View-Controller)
  \item Mondo di gioco dinamico, con entità in movimento, animazioni e suoni
  \item Ostacoli e nemici da evitare
  \item Gestione dei profili utente e persistenza dei punteggi
  \item Oggetti da raccogliere e utilizzare (Freeze, Reset ascensori ecc.)
\end{itemize}

Il gioco è stato sviluppato con l'idea di sfruttare e adottare svariati pattern di progettazione del
software per poterne conoscere punti di forza e limiti, oltre che per rendere il codice più lineare e manutenibile.
Inoltre è stata posta particolare attenzione alla separazione delle responsabilità tra le varie componenti del pattern MVC ed è stata
promossa la modularità del codice che ha facilitato l'estensione del progetto con funzionalità aggiuntive.

\subsection{Panoramica dell'architettura}
L'architettura di \textbf{JImpossible Mission} è organizzata come segue:
\begin{itemize}
  \item \textbf{Model}: è il cuore del progetto. Gestisce le logiche del gioco, le interazioni tra le entità e rappresenta lo stato del mondo di gioco. \\[2pt]
    \textit{Subpackages}: \texttt{entity}, \texttt{manager}, \texttt{physics}, \texttt{game}, \texttt{scene}, \texttt{item}, \texttt{profile}.
  \item \textbf{View}: si occupa della rappresentazione grafica utilizzando coma base \textbf{Java Swing}, estendendone i componenti. Gestisce le interfacce dei menù, le animazioni e gli effetti audio del gioco \\[2pt]
    \textit{Subpackages}: \texttt{animation}, \texttt{audio}, \texttt{color}, \texttt{hud}, \texttt{item}, \texttt{menu}, \texttt{ui}.
  \item \textbf{Controller}: riceve gli input da tastiera (tramite \texttt{InputController}), li normalizza in comandi di gioco (azioni) e li passa al Model. Contiene inoltre il \textbf{game loop}, che scandisce l'aggiornamento periodico dello stato del gioco.
\end{itemize}
\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{assets/jimpossible_overview.png}
\end{figure}
Come si evince dal diagramma, il flusso di dati principale avviene all'interno del ciclo di gioco (game loop), il Model viene aggiornato regolarmente e la View viene notificata alla fine di ogni ciclo di update per ridisegnare la scena corrente.

\section{Il Controller}
Per iniziare ad approfondire l'architettura del progetto, partiamo dal \textbf{Controller}, che rappresenta il punto di ingresso principale dell'applicazione.
Il Controller si occupa di gestire il ciclo di vita dell'applicazione, avviando e terminando il gioco in modo appropriato e gestendo le logiche tra le interfacce visualizzate.
Spetterà poi al Model e alla View di occuparsi rispettivamente dell'implementazione delle logiche e della rappresenzentazione grafica.

\subsection{Il Game Loop}
Una volta inizializzato il Model, e aggiunta la View del gioco ai listener del model, secondo il pattern \textbf{Observer/Observable}, il Controller avvia il \textbf{game loop}.
Il \textbf{game loop} è il ciclo principale che gestisce l'aggiornamento del gioco, ad intervalli regolari (anche se con minime fluttuazioni dovute al carico e alla velocità della CPU).
Per la realizzazione del progetto il primo passo compiuto è stata la definizione di un ciclo di aggiornamento continuo.
Grazie ad esso è possibile gestire interazioni in tempo reale (tramite \textit{polling} degli input) e aggiornare lo stato del gioco.
Per fare ciò, nel nostro caso, si utilizza un ciclo \textbf{while} che continua finché il gioco è in esecuzione e si definisce il numero di aggiornamenti desiderati in un certo intervallo di tempo.
Un buon compromesso tra fluidità e prestazioni, molto comune nel settore dei videogiochi, è impostare un aggiornamento di \textbf{60 volte al secondo}.

La logica del model viene quindi aggiornata ad ogni iterazione del ciclo, tenendo conto del tempo trascorso dall'ultimo aggiornamento, fondamentale per calcoli di movimenti con velocità e \textbf{collision resolution}.
Questo intervallo di tempo è definito come \textbf{frame time}, che rappresenta appunto il tempo minimo tra due aggiornamenti consecutivi.
Il frame time è calcolato come l'inverso del numero di aggiornamenti desiderati al secondo (FPS - Frames Per Second):
\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\(
      \text{FRAME\_TIME} = \dfrac{1}{\text{FPS}}
  \)}
\end{center}
Invece, il tempo effettivo tra due aggiornamenti consecutivi viene denominato \(\Delta t\) (delta time) e viene calcolato come la differenza tra il tempo corrente e il tempo dell'ultimo aggiornamento.
Per evitare problemi di calcolo, specie per collision manager e motori fisici, in caso di cali improvvisi di prestazioni, è buona pratica definire un \textbf{max frame time}, che limita il tempo massimo tra due aggiornamenti consecutivi.
Pertanto, per i calcoli interni al model, il \textit{delta time} viene normalizzato e limitato tra il frame time e il max frame time:
\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\(
      \Delta t = \max(\text{FRAME\_TIME}, \min(\text{MAX\_FRAME\_TIME}, \Delta t))
  \)}
\end{center}
Il codice del game loop è stato implementato nel nel seguente modo:

\begin{lstlisting}[language=Java]
TARGET_FPS = 60.0f;
FRAME_TIME = 1.0f / TARGET_FPS; // Timestep base
MAX_FRAME_TIME = 3.0f / TARGET_FPS; // Massima fluttuazione del timestep
private static final long FRAME_TIME_NS = (long) (FRAME_TIME * 1_000_000_000);

private static void runGameLoop(Model m, InputController inputController) {
        long lastTime = System.nanoTime();

        // gameRunning e' una variabile boolean condivisa (volatile) che indica se il gioco e' in esecuzione
        while (gameRunning && !Thread.currentThread().isInterrupted()) {
            long currentTime = System.nanoTime();
            long deltaTime = currentTime - lastTime;

            // Controlla se e' passato il tempo sufficiente per definire un frame
            if (deltaTime >= FRAME_TIME_NS) {
                float dt = deltaTime / 1_000_000_000f;
                dt = Math.max(FRAME_TIME, Math.min(MAX_FRAME_TIME, dt));
                // Aggiorna lo stato del gioco, passando il delta time normalizzato e gli input correnti
                m.updateGameState(new HashSet<>(inputController.getInputState()), dt);
                lastTime = currentTime;
            } else {
                long remainingTime = FRAME_TIME_NS - deltaTime;
                // Se manca ancora 'molto' tempo al prossimo frame, metti il thread in sleep per ridurre l'uso della CPU
                if (remainingTime > 2_000_000) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
    }
\end{lstlisting}

Il game loop inizia registrando il tempo corrente in nanosecondi.
All'interno del ciclo while, calcola il tempo trascorso dall'ultimo aggiornamento (deltaTime).
Se questo tempo supera il frame time desiderato (\texttt{FRAME\_TIME\_NS}),
aggiorna lo stato del gioco chiamando il metodo updateGameState del Model, passando gli input correnti e il delta time normalizzato.
Dopo l'aggiornamento, aggiorna lastTime al tempo corrente. Se il deltaTime è inferiore al frame time,
il thread dorme per un breve periodo per evitare un utilizzo eccessivo della CPU (\textit{busy waiting}).

Ad ogni iterazione del ciclo inoltre, viene passato al Model lo stato corrente degli input raccolti dal Controller.
\subsection{L'InputController}
Per semplificare il passaggio degli input al Model, è stata definita una classe chiamata \textbf{InputController} che si occupa di catturare gli input da tastiera, implementando l'interfaccia \texttt{KeyListener} di Java Swing.
\begin{lstlisting}[language=Java]
  public class InputController implements KeyListener {
    private final Set<Integer> pressedKeys = ConcurrentHashMap.newKeySet();

    @Override
    public void keyTyped(KeyEvent e) {
        // No-op
    }

    @Override
    public void keyPressed(KeyEvent e) {
        pressedKeys.add(e.getKeyCode());
    }

    // Rimuove il keyCode dal set al release del tasto.
    @Override
    public void keyReleased(KeyEvent e) {
        pressedKeys.remove(e.getKeyCode());
    }

    public Set<Action> getInputState() {
        return pressedKeys.stream().map(Action::fromKeyCode)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
    }
}
\end{lstlisting}
La logica alla base di questa classe è semplice: mantiene un insieme di tasti attualmente premuti (pressedKeys) e aggiorna questo insieme in risposta agli eventi di pressione e rilascio dei tasti.
Il metodo \texttt{getInputState} restituisce lo stato corrente degli input che verranno successivamente filtrati e mappati in azioni di gioco dal Model.
\newpage
\subsection{Gestione delle interfacce}
Il Controller si occupa anche di connettere le varie interfacce grafiche passando le funzioni che verranno eseguite al verificarsi di determinati \textit{input} dell'utente.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{assets/menu_navigation.png}
\end{figure}
Quando vengono eseguiti determinati comandi nella View, il Controller si occuperà di eseguire le azioni corrispondenti, come avviare la partita, salvare le modifiche ai profili utente e interfacciarsi con il model per caricare o salvare i dati.

\section{Analisi e pianificazione del gioco}
Prima di proseguire con lo sviluppo delle logiche di gioco, bisogna soffermarsi su come sviluppare e riprodurre alcuni punti fondamentali.
Questo processo inizia con l'individuare le entità principali di gioco, il piano di riferimento del mondo di gioco all'interno del Model e come viene riportato visivamente nella View.
\subsection{Geometrie e coordinate}
Per la gestione delle posizioni è stato individuato un sistema di coordinate cartesiane 2D, con l'origine (0,0) nell'angolo in alto a sinistra dello schermo, definito da una coppia di valori interi (x,y).
Il sistema è stato sviluppato ragionando in \textbf{pixel}, in modo da semplificare i calcoli di posizionamento e movimento delle entità ed uniformare poi il calcolo che verrà effettuato nella View.
\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\parbox{0.9\linewidth}{\small
      Nonostante si lavori in pixel, il Model non ha una vera e propria "risoluzione". E' però un'astrazione che aiuta a definire le logiche di posizionamento.
      Le dimensioni delle entità e della finestra possono essere \textit{scalate} a piacimento nel layer di presentazione, preservando \textbf{integralmente} le logiche sottostanti.
  }}
\end{center}
I vari scenari sono stati progettati su una griglia di \textbf{32x32} pixel per cella, individuati come Tile e utilizzati per posizionare pavimenti, muri, oggetti di scena e piattaforme.
Di conseguenza, la dimensione di ogni stanza è stata definita come multiplo di 32 pixel, andando a definire un'area di gioco di \textbf{40x25} tiles (width x height),
una dimensione che si adatta bene alla tipologia di gioco ed è simile alla grandezza delle mappe originali. Le entità nel Model, verranno dimensionate in base al rapporto di grandezza rispetto alla dimensione del tile.
\subsection{Costruzione delle mappe}
\label{sec:map_building}
Per agevolare lo sviluppo, il debug dei vari livelli e la creazione di nuove mappe, è stato pensato un semplice formato di file di testo, rappresentante la griglia di tiles e le entità presenti con caratteri ASCII.
\begin{lstlisting}[language=Java]
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . @ . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . ~ . . . . . . . . . . . . . . . . . . . |
| . X . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . # # # # # # # # # # # # # # . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . # # # # # . . . . . . ~ . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . # # # # # # # # # # # # # . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . |
> . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . >
> . . . . . . . @ . . . . . . . . @ . . . . . . . | . . . . . . . . . . . . . >
> . . . . . . . . . . . . C . . . . . . . . . . . | . . . . . C . . . . . . . >
> . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . >
> . . . . . . . . . . . . . . . . . . . . . . . . | . . . . . . . . . . . . . >
# # # # # # # # # # # # # # # # # # # # # # ^ . . | ^ . . # # # # # # # # # # #
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
\end{lstlisting}
In questo modo i livelli possono essere creati e modificati facilmente tramite editor di testo, fornendo una rappresentazione semplificata della disposizione delle entità e degli oggetti all'interno del gioco.
Ogni carattere rappresenta un diverso tipo di tile o entità, ad esempio:
\begin{itemize}
  \item \texttt{.} : Spazio vuoto
  \item \texttt{\#} : Pavimento
  \item \texttt{X} : Uscita
  \item \texttt{@} : Nemico
  \item \texttt{C} : Computer
  \item \texttt{\textasciitilde} : Collezionabile
  \item \texttt{\^} : Ascensore
  \item \texttt{>} : Porte della stanza
\end{itemize}
Il parsing di questi file di testo avviene all'avvio del gioco; verranno illustrati in seguito i dettagli tecnici dell'implementazione.
\subsection{Sistema di collisioni}
Il gioco, essendo un platform 2D, richiede un sistema di gestione delle collisioni.
Non avendo meccaniche particolari legate alle animazioni o hitbox dinamiche, si può implementare un sistema basato su \textbf{Axis-Aligned Bounding Box} (AABB), in modo da semplificare calcoli di intersezione e non appesantire la macchina.
Ogni entità solida (muri, pavimenti, piattaforme, ascensori) avrà una hitbox rettangolare definita dalle sue coordinate e dimensioni.
Le entità mobili (player, nemici) avranno anch'esse una hitbox AABB, e ad ogni aggiornamento del game loop, il sistema di collisioni verificherà se la hitbox di un'entità mobile interseca quella di un'entità solida.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{assets/AABB_collision.png}
  \caption{Esempio di collisione AABB (fonte: \href{https://www.amanotes.com/post/using-swept-aabb-to-detect-and-process-collision}{Amanotes}).}
\end{figure}

\newpage
\section{Panoramica del Model}
Il Model, sviluppato con pattern \textbf{Singleton}, implementa l'interfaccia \textbf{Observable} per notificare alla View gli aggiornamenti dello stato di gioco.
Il punto di ingresso principale del Model è il metodo \texttt{updateGameState}, che viene chiamato ad ogni iterazione del game loop, ricevendo in input i comandi e il tempo trascorso dall'ultimo aggiornamento (\(\Delta t\)).

Il mondo di gioco è rappresentato da una serie di strutture dati e entità che rappresentano in maniera logica i vari aspetti del gioco.
Queste strutture dati sono organizzate in vari package all'interno del Model, ognuno con una responsabilità specifica.
\subsection{Unità geometriche e fisiche}
Per posizionare correttamente le entità nel mondo di gioco, il progetto definisci due geometri fondamenti:
\begin{itemize}
  \item \textbf{Point}: rappresenta una posizione nel mondo di gioco, definita da una coppia di coordinate intere (x,y)
  \item \textbf{Bounds}: rappresenta un'area rettangolare nel mondo di gioco, definita da due punti (Point) che rappresentano l'angolo in alto a sinistra e l'angolo in basso a destra del rettangolo.
\end{itemize}
Queste classi forniscono metodi per calcolare intersezioni, verificare se un punto è contenuto all'interno di un'area e altre operazioni geometriche fondamentali.
Per la gestione dei movimenti invece è stata definita la classe \textbf{Vector2}, su ispirazione del \textit{motore Unity}, che rappresenta un vettore bidimensionale composto da due componenti \textbf{float}.
La classe implementa inoltre le funzioni matematiche di base per operare con i vettori, come somma, moltiplicazione per uno scalare, normalizzazione, ma espone anche metodi di comodo come cambio di direzione e conversione in Point.

Il gioco inoltre ha richiesto l'utilizzo di un semplice motore fisico per gestire i movimenti di una tipologia di nemico e per simulare la gravità sul giocatore.
Per questo scopo è stata definita la classe \textbf{Force}, rappresentata da un Vector2 e da un \textbf{ForceType} (enum IMPULSE, CONSTANT).
L'idea di base è che le forze di tipo IMPULSE vengono applicate una sola volta (es. salto del giocatore) e si consumano, mentre le forze di tipo CONSTANT vengono applicate ad ogni aggiornamento (es. gravità).

\subsection{Entity e pattern di progettazione}
Il package Entity le classi che rappresentano ogni entità del gioco: dai blocchi statici come muri e pavimenti, alle entità dinamiche come il giocatore.
Alla base di ogni entità è stata individuata la classe astratta \textbf{Entity}, che definisce le proprietà comuni a tutte le entità:
\begin{itemize}
  \item ID univoco
  \item Posizione
  \item Funzioni di rimozione dal gioco
  \item Metodi astratti per eventi come \textit{onRoomLeave}, \textit{onRoomReset} ecc. che verranno implementati dalle sottoclassi
\end{itemize}
\begin{figure}[h]
  \centering
  \includegraphics[width=0.65\textwidth,height=0.2\textheight,keepaspectratio]{assets/entity_uml.png}
\end{figure}
La classe Entity viene poi estesta per comporre le entità specifiche del gioco, come \texttt{Player} e \texttt{Robot}, implementando interfacce aggiuntive
utilizzate per categorizzare le entità all'interno dei rispettivi manager: ad esempio, il Player implementa le interfacce \texttt{ActionReceiver}, \texttt{BoundingBox}, \texttt{Interactor} e \texttt{Damageable},
quindi il sistema saprà che il Player può ricevere azioni, ha una hitbox per le collisioni, può interagire con oggetti e può subire danni.

\subsubsection{\textit{Interfaces}, \textit{Managers} e composizione delle entità}
Come anticipato, le interfacce utilizzate nel Model sono caratterizzanti della tipologia entità e vengono utilizzate dai vari manager per specifiche funzionalità:
\begin{itemize}
  \item \textbf{Damageable}: espone un getter per un BoundingBox che rappresenta l'area in cui l'entità può subire danni
  \item \textbf{Damager}: espone un getter per un BoundingBox che rappresenta l'area in cui l'entità può infliggere danni
  \item \textbf{Ephemeral}: interfaccia marker per entità che devono essere rimosse in fase di cleanup (es. proiettili, shockray dei Robot)
  \item \textbf{Interactable}: espone un getter per un BoundingBox che rappresenta l'area in cui l'entità può essere interagita
  \item \textbf{Interactor}: espone un getter per un BoundingBox che rappresenta l'area in cui l'entità può interagire con altre entità
  \item \textbf{Solid}: interfaccia marker per entità solide, come muri, pavimenti e ascensori
  \item \textbf{Static}: interfaccia marker per entità statiche, che non hanno alcuna funzionalità di movimento (muri, pavimenti ecc.)
\end{itemize}
\begin{figure}[h]
  \centering
  \includegraphics[width=0.85\textwidth]{assets/interfaces.png}
\end{figure}
La lista di interfacce non è esaustiva, ma rappresenta i principali metodi di categorizzazione delle entità.

I \textbf{Manager} delle entità, in questo software, sono istanze che si occupano di gestire le logiche di collisione in base alle interfacce integrate nelle entità.
Sono presenti 3 tipi principali di manager:
\begin{itemize}
  \item \textbf{CollisionManager}: specializzato nella gestione delle collisioni tra entità solide (Solid) e nel risolvere i movimenti di Player e nemici in movimento, verrà descritto in dettaglio nella sezione relativa alle collisioni.
  \item \textbf{EntityManager}: contiene e gestisce tutte le entità presenti nel contesto corrente e getters per ottenere liste di entità in base a specifiche interfacce (es. tutti i Damager presenti)
  \item \textbf{ComponentManager}: classe astratta con interfacce generiche che restituisce metodi per rilevare le collisioni tra entità tra interfacce specifiche (es. Interactor vs Interactable, Damager vs Damageable)
\end{itemize}
Si riporta di seguito la classe \textbf{ComponentManager}.
\begin{lstlisting}[language=Java]
  /**
  * Manager generico per componenti di tipo {@code T}.
  * Fornisce utilita' per recuperare candidati e filtrarli per area e tipo.
  *
  * @param <T> tipo degli elementi gestiti
  */
  public abstract class ComponentManager<T> {
    protected final EntityManager entityManager;

    /**
    * Funzione che mappa un elemento {@code T} ai suoi {@link Bounds} per i test di intersezione.
    */
    private final Function<T, Bounds> getCandidateBounds;

    /**
    * Costruisce un ComponentManager con il relativo EntityManager e la funzione di bounds.
    *
    * @param entityManager      gestore delle entita'
    * @param getCandidateBounds funzione che ritorna i bounds per ciascun candidato
    */
    public ComponentManager(EntityManager entityManager,
    Function<T, Bounds> getCandidateBounds) {
      this.entityManager = entityManager;
      this.getCandidateBounds = getCandidateBounds;
    }

    /**
    * Restituisce la lista completa dei candidati gestiti.
    *
    * @return lista di candidati di tipo {@code T}
    */
    public abstract List<T> getCandidates();

    /**
    * Filtra i candidati i cui bounds intersecano gli {@code actorBounds} forniti.
    *
    * @param actorBounds bounds di riferimento per il filtro
    * @return stream di candidati che intersecano {@code actorBounds}
    */
    private Stream<T> getCandidatesInAreaStream(Bounds actorBounds) {
      return getCandidates().stream().filter(el -> getCandidateBounds.apply(el).intersects(actorBounds));
    }

    /**
    * Restituisce i candidati nell'area castati al tipo richiesto.
    *
    * @param actorBounds area di ricerca
    * @param type        classe del tipo desiderato
    * @param <U>         tipo di ritorno richiesto
    * @return lista di elementi di tipo {@code U} presenti nell'area
    */
    public <U> List<U> getCandidatesInAreaByType(Bounds actorBounds, Class<U> type) {
      return getCandidatesInAreaStream(actorBounds).filter(type::isInstance).map(type::cast).toList();
    }

    /**
    * Restituisce il primo candidato nell'area che e' istanza del tipo richiesto.
    *
    * @param actorBounds area di ricerca
    * @param type        classe del tipo desiderato
    * @param <U>         tipo opzionale di ritorno
    * @return Optional contenente il primo elemento di tipo {@code U} se presente
    */
    public <U> Optional<U> getFirstCandidatesInAreaByType(Bounds actorBounds, Class<U> type) {
      return getCandidatesInAreaStream(actorBounds).filter(type::isInstance).map(type::cast).findFirst();
    }

    /**
    * Restituisce tutti i candidati che intersecano gli {@code actorBounds}.
    *
    * @param actorBounds bounds di riferimento
    * @return lista di candidati in area
    */
    public List<T> getCandidatesInArea(Bounds actorBounds) {
      return getCandidatesInAreaStream(actorBounds).toList();
    }

    /**
    * Restituisce il primo candidato che interseca gli {@code actorBounds}, se presente.
    *
    * @param actorBounds bounds di riferimento
    * @return Optional con il primo candidato nell'area
    */
    public Optional<T> getFirstCandidateInArea(Bounds actorBounds) {
      return getCandidatesInAreaStream(actorBounds).findFirst();
    }
  }
\end{lstlisting}
\subsubsection{Player, Enemy e StatePattern}
Il \textit{Player} e i \textit{Robot} (nemici) sono entità dinamiche che richiedono una gestione ad-hoc per le loro logiche di movimento e di interazione.
I comportamenti dipendono spesso dallo stato corrente dell'entità, ad esempio se il Player è a terra, può saltare, se è in aria non può effettuare un altro salto e subisce la gravità.
Per gestire questi stati in modo pulito e modulare, è stato adottato il \textbf{State Pattern}.
Il Player ha una serie di stati che implementano le logiche specifiche di update e gestione degli input.
Prendiamo ad esempio la classe astratta \textbf{PlayerState}:
\begin{lstlisting}[language=Java]
public abstract class PlayerState implements State {
    protected static final Bounds NORMAL_BOUNDS = new Bounds(40, 110);
    protected final Player player;
    private static long nextId = 0;
    protected final long ID;

    public PlayerState(Player ctx) {
        this.player = ctx;
        ID = nextId++;
    }

    public void onEnter() {
    }

    public void onExit() {
    }

    @Override
    public long getID() {
        return ID;
    }

    public abstract void handleInput(Set<Action> actions, SceneContext sceneContext);

    public abstract void tick(SceneContext context, float deltaTime);

    // Gestisce l'asse orizzontale e restituisce -1 per sinistra +1 per destra
    protected int handleHorizontalInput(Set<Action> actions) {
        int x = 0;
        int s = Player.SPEED;

        if (actions.contains(Action.LEFT))
            x -= s;
        if (actions.contains(Action.RIGHT))
            x += s;

        if (x > 0) {
            player.facing = Facing.RIGHT;
        } else if (x < 0) {
            player.facing = Facing.LEFT;
        }

        player.physicsState.velocity.x = x;
        return Integer.signum(x);
    }

    protected boolean isOnGround(SceneContext context) {
        return player.isOnGround(context);
    }

    protected boolean handleDamageCollision(SceneContext context) {
        Optional<Damager> damager = context.getDamageManager().getFirstCandidateInArea(player.getDamageableBounds());
        if (damager.isPresent()) {
            switch (damager.get().getDamageType()) {
                case DamageType.FALL:
                    player.changeState(new FallDamagedPlayerState(player));
                    break;
                case DamageType.ZAP:
                default:
                    player.changeState(new DamagedPlayerState(player));
            }
            return true;
        }

        return false;
    }

    public Bounds getBounds() {
        return NORMAL_BOUNDS.anchorCenterBottom(Player.ENTITY_BOUNDS.moveCenter(player.getPosition()));
    }
}
\end{lstlisting}
La classe fornisce metodi di comodo per gestire gli input orizzontali, ma la potenzialità del pattern risiede nei metodi astratti \texttt{handleInput} e \texttt{tick}.
Questi metodi vengono implementati nelle classi concrete e rappresentano il punto d'ingresso per gestire l'update delegato allo stato corrente dell'entità.
\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{assets/player_state_uml.png}
  \caption{Schema UML semplificato dello StatePattern per la classe Player.}
\end{figure}
Analogamente, le entity nemiche utilizzano lo stesso principio, ma a differenza del Player,
il loro stato non viene alterato da input ma viene interamente gestito da una semplice IA definita all'interno degli stati.

\subsubsection{Ascensori e Observable Pattern}
Gli ascensori sono entità che permettono al Player di spostarsi verticalmente tra i vari piani della stanza.
Per gestire il loro funzionamento, è stato adottato l'\textbf{Observer Pattern}, con una implementazione personalizzata, per scopi didattici.
E' stata così definita l'interfaccia \textbf{ObservableEntity} che espone i metodi per aggiungere, rimuovere ed eseguire dei listener, che saranno del tipo \textbf{Consumer<T>}.
\begin{lstlisting}[language=Java]
  public abstract class ObservableEntity<T> extends Entity {
    /**
     * Collezione thread-safe di listener registrati per ricevere eventi.
     */
    private final List<Consumer<T>> listeners = new CopyOnWriteArrayList<>();

    public ObservableEntity() {
        super();
    }

    public ObservableEntity(Point position) {
        super(position);
    }

    protected int getListenerCount() {
        return listeners.size();
    }

    public void addListener(Consumer<T> listener) {
        listeners.add(listener);
    }

    public void removeListener(Consumer<T> listener) {
        listeners.remove(listener);
    }

    protected void sendEvent(T value) {
        for (Consumer<T> listener : listeners) {
            listener.accept(value);
        }
    }
}
\end{lstlisting}
Gli ascensori estendono questa classe e definiscono un eventi specifici di \textbf{spostamento} e di \textbf{completamento} tramite la classe \textbf{ElevatorEvent}.

\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\parbox{0.9\linewidth}{\small
      Gli ascensori inoltre contengono una struttura denominata \textbf{StepList<T>}, un estensione di \textit{ArrayList<T>} che usa un \textbf{Comparator} per ordinare i punti in base a dei criteri prestabiliti.
      L'instanziazione nell'ascensore avviene nel seguente modo:
      \lstinline[language=Java]!StepList<Point> targets = new StepList<>(Comparator.comparingInt(Point::y))!
      I punti vengono ordinati in base alla distanza verticale da (y = 0). StepList espone inoltre un'\textbf{iteratore bidirezionale}, il perfetto cursore per muoversi tra i vari piani.
      \newline
      {\small\textsf{\textcolor{codepurple}{\textit{Si rimanda alla sezione~\ref{sec:steplist} (\textit{Struttura StepList e StepIterator}) in appendice per i dettagli implementativi.}}}}
  }}
\end{center}

Il Player, dopo aver interagito con l'ascensore, entra nello stato \textbf{ElevatorPlayerState} che lo rende immobile e riceve lo spostamento che viene effettuato dall'ascensore tramite un listener registrato.
Una volta raggiunta la destinazione, l'ascensore invia un evento di completamento al Player che esce dallo stato e riprende il controllo.
\newline
{\small\textsf{\textcolor{codepurple}{Si rimanda alla sezione~\ref{sec:elevator_player_state} in appendice per i dettagli implementativi.}}}

\subsubsection{Oggetti di scena e interazioni}
Nel gioco sono presenti degli oggetti di scena con cui il Player può interagire. Questi oggetti possono contenere degli attivabili che possono essere utilizzati al terminale,
parti di schede perforate che faranno progredire il Player nella decifratura della password oppure possono anche essere vuoti.
Gli oggetti di scena sono rappresentati dalla classe \textbf{SceneObject} che implementa l'interfaccia \texttt{Interactable}.
Essi contengono un riferimento ad un'istanza di \textbf{Collectible} che garantirà il giocatore dell'oggetto corrispondente una volta terminata l'ispezione

\subsection{Room, SceneContext e gestione delle stanze}
Il mondo di gioco è suddiviso in stanze, all'interno delle quali sono posizionate entità.
Per implementare questa suddivisione sono state definite una serie di classi:
\begin{itemize}
  \item La classe \textbf{Room} rappresenta una singola stanza di gioco. Qui avviene il parsing del file di testo che definisce la mappa, come accennato nel paragrafo ~\ref{sec:map_building}.
  \item La classe \textbf{SceneContext} fornisce un contesto di esecuzione per la stanza corrente,
    esponendo riferimenti ai manager delle entità, al CollisionManager e ad altri componenti necessari per l'aggiornamento del gioco.
  \item La classe \textbf{SceneManager} gestisce la transizione tra le stanze, caricando la stanza successiva quando il Player raggiunge le uscite.
\end{itemize}
Il Player può spostarsi tra le stanze mediante l'entità \textbf{Portal}, uno speciale \textbf{Trigger} che implementa l'interfaccia \textit{Interactable}.
Il Portal, essendo un area di \textit{trigger}, non richiede un'azione esplicita da parte del giocatore per essere attivato, eseguirà automaticamente la funzione assegnata in fase di creazione.
Contiene inoltre il \textbf{Point} dover il Player verrà posizionato una volta entrato nella nuova stanza.

\subsection{Progresso di gioco}
Il progresso di gioco viene gestito tramite la classe \textbf{GameData}, contenuta da \textbf{Game} un \texttt{Singleton} che ne fornisce il riferimento.
\textit{GameData} contiene informazioni sul profilo utente corrente, i collezionabili ottenuti, la password in corso di decifrazione e il tempo di gioco trascorso.
Una volta terminata la partita, la classe è delegata al calcolo del punteggio in base alle perfomance del giocatore.

\subsection{Punchcard e sistema di password}
Un elemento chiave del gioco è il sistema di decifrazione della \textbf{password} tramite le schede perforate (\textbf{punchcard}).
All'avvio di ogni partita, una \textbf{password} viene pescata casualmente da un elenco predefinito e suddivisa in segmenti di 2 caratteri.
Ogni segmento corrisponde nel gioco a una scheda perforata, implementata come classe \textit{\textbf{Punchcard}},
suddivisa a sua volta in \textbf{3 frammenti}, rappresentati da \textbf{PunchCardPiece} che implementa \texttt{Collectible}.

Per rappresentare questa meccanica di gioco, è stato deciso di esplorare un approccio basato su bit e calcoli su \textbf{bitmask}.
Ogni \textbf{punchcard} è rappresentata da \textbf{3 bit}, 1 bit per ogni frammento, dove un bit settato a 1, all'interno di una variabile di tipo \texttt{int} che conterrà i frammenti recuperati, indica che il frammento è stato raccolto.
Per ogni punchcard recuperata, una parte di \textbf{password} viene svelata al giocatore. Una volta raccolte tutte le punchcard, la password sarà completamente visibile e il giocatore potrà raggiungere la porta di uscita e terminare la partita.

\section{Struttura della View}
La View è responsabile della rappresentazione grafica del gioco e dell'interfaccia utente.
Come anticipato, è stat sviluppata utilizzando la librearia JavaSwing, che fornisce componenti GUI e funzionalità di rendering 2D.

Le parti principali della View sono 2:
\begin{itemize}
  \item \textbf{Menù iniziale}: Schermata iniziale del gioco, che permette di avviare una nuova partita, caricare un profilo esistente o modificare le impostazioni.
  \item \textbf{GameView}: Schermata di rendering, responsabile del disegno del gioco.
\end{itemize}
Per la realizzazione del menù iniziale è stato utilizzato il CardLayout all'interno del JPanel principale, in modo da poter passare da una schermata all'altra in maniera pulita.

Il pannello di rendering invece estende JPanel, e all'avvio del gioco, il controller rimuove il menù iniziale e aggiunge il pannello di rendering.
Il rendering vero e proprio avviene sovrascrivendo il metodo \texttt{paintComponent(Graphics g)}, ed è l'unico pannelo che viene istanziato durante il gioco.
Tutte le entità grafiche implementano l'interfaccia \textbf{Drawable}, che espone il metodo \texttt{draw(Graphics2D g2d, float deltaTime)}.

Ogni volta che il \textbf{Model} notifica un cambiamento di stato, ovvero ad ogni iterazione del game loop (anche se non necessariamente), il metodo \texttt{repaint()}
viene chiamato sul pannello di rendering ed ogni entità disegnabile viene renderizzata a schermo.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\textwidth]{assets/view_overview.png}
  \caption{Schema semplificato rendering.}
\end{figure}

\begin{center}
  \setlength{\fboxsep}{8pt}
  \fcolorbox{codepurple}{backcolour}{\parbox{0.9\linewidth}{\small
      Le entità nel \textbf{Model} contengono un ID univoco, che viene sfruttato dalla View per mantenere una mappa di \textbf{EntityView} associate alle entità,
      organizzata per \textbf{Layer} che ne determina l'ordine di rendering.
      In questo modo, ad ogni aggiornamento del gioco, la View può recuperare le istanze grafiche presenti nella scena senza doverle istanziare nuovamente, o rimuovere quelle non più presenti.
      \newline
      \lstinline[language=Java]!Map<Layer, Set<EntityView<?>>> views = Collections.synchronizedMap(new EnumMap<>(Layer.class));!
      \newline
      La mappa, come si nota dal codice, è una synchronizedMap per garantire la sicurezza in caso di accessi concorrenti, ed eliminare errori che sono stati riscontrati durante lo sviluppo.
  }}
\end{center}

\subsection{Sistema di rendering e Layer}
I layer nel gioco sono stati implementati tramite un enum \textbf{Layer}, che riassume i principali gruppi di entità grafiche presenti nel gioco.
\begin{itemize}
  \item TILE, utilizzato per pavimenti, muri ed elementi statici di sfondo
  \item INTERACTABLE, su questo layer vengono disegnati oggetti, porte e terminali
  \item ENEMIES, layer dei nemici
  \item PLAYER, layer del giocatore
  \item HUD, utilizzato per disegnare HUD e overlay a schermo
\end{itemize}
Ogni entità grafica implementa il metodo \texttt{getLayer()} che restituisce il layer di appartenenza,
in modo che la View possa organizzare l'ordine di rendering per ciascuna entità presente nella scena.

\subsection{Struttra di una EntityView}
L'\textbf{EntityView}, come \textbf{Entity} per il Model, è la classe base per tutte le entità grafiche del gioco.
E' una classe astratta generica che accetta come parametro di tipo l'entità del Model a cui è associata, contenendo il riferimento ad essa.

Le entità, a seconda del ruolo che hanno all'interno del gioco, sono rappresentate e composte in modi differenti.
Abbiamo entità statiche come muri e pavimenti, che non richiedono animazioni o cambiamenti di stato, o entità dinamiche come il Player e i nemici.
Per gestire questa varietà, ogni sottoclasse di EntityView includerà o meno istanze di \textbf{AnimationPlayer} o semplici \textbf{BufferedImage}
per rappresentare l'entità a schermo. Inoltre, alcune entità possono riprodurre suoni e saranno dotate di un'istanza di
\textbf{AudioAnimationPlayer} (se legati ad animazioni) o di \textbf{AudioPlayer}

\subsection{Gestione degli assets grafici e colori}
Considerando il gioco originale, dove ogni stanza ha una palette di colori specifica, è stato deciso di prevedere questa funzionalità anche in questa versione.
Come palette di colori, è stata utilizzata una palette ispirata al \textbf{Commodore 64}, con 16 colori distinti, inseriti nella classe \textbf{C64Color}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth,draft=false]{assets/commodore64-32x.png}
  \caption{Palette C64}
\end{figure}
Una volta definita la palette, sono state individuate le entità che richiedono una colorazione differente per stanza:
\begin{itemize}
  \item Muri e pavimenti
  \item Ascensori
  \item Background
  \item Nemici
  \item Collezionabili
\end{itemize}
Per queste entità, sono stati utilizzati degli \textbf{spritesheet} con colori speciali, dove ogni colore dello sprite viene
sostiuito in fase di creazione dell'oggetto da un colore appartene alla palette C64.
I channel utilizzati per la sostituzione sono:
\begin{itemize}
  \item Rosso: rgb(255,0,0)
  \item Magenta: rgb(255,0,255)
  \item Blu: rgb(0,0,255)
  \item Ciano: rgb(0,255,255)
  \item Verde: rgb(0,255,0)
  \item Giallo: rgb(255,255,0)
  \item Grigio: rgb(128,128,128) (channel per background)
\end{itemize}
\begin{figure}[h]
  \centering
  \colorbox{backcolour}{%
    \begin{minipage}{0.6\textwidth}
      \includegraphics[width=\textwidth,draft=false]{assets/robot.png}\\[8pt]
      \rule{0pt}{14pt}% padding bottom
    \end{minipage}%
  }
  \caption{Spritesheet con channel Robot}
\end{figure}
La sostituzione del colore viene effettuata utilizzando principalmente l'oggetto \textbf{ColorMapping}, una classe personalizzata che estende \texttt{HashMap<Color, Color>}.

Questa classe, mediante il metodo \lstinline[language=Java]!BufferedImage applyTo(BufferedImage image)! permette di mappare i canali definiti nella sua struttura dati,
che utilizza come chiave i channel da sostituire e come valore il colore che lo sostituirà.
Nel gioco sono state definite 4 istanze di ColorMapping, assegnate in maniera casuale alle stanze durante l'esplorazione della base.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\textwidth,draft=false]{assets/colore_mapping.png}
  \caption{Spritesheet con channel Robot}
\end{figure}
\newpage
\section{Posizionamento e movimento delle entità}
Ogni elemento nel gioco è rappresentato come un'istanza della classe Entity. Questa contiente informazioni riguardanti la posizione e la dimensione.
I posizionamenti nel software sono gestiti tramite coordinate cartesiane in un sistema 2D, dove l'origine (0,0) si trova nell'angolo in alto a sinistra dello schermo.
Le coordinate sono rappresentate dalla classe Point che contiene due valori interi, x (ascissa) e y (ordinata), in pixel.

Le entità a seconda del caso, posso avere anche una velocità (rappresentata in pixel/secondo) e lo spostamento viene calcolato ad ogni aggiornamento del game loop,
utilizzando la formula:
\begin{equation}
  \text{newPosition} = \text{currentPosition} + \text{velocity} \times \Delta t
\end{equation}
dove \(\Delta t\) è il tempo trascorso dall'ultimo aggiornamento, fornito dal game loop.

\appendix
\section{Appendice}
Dettagli tecnici aggiuntivi.

\subsection{Struttura StepList e StepIterator}
\label{sec:steplist}
La struttura \texttt{StepList<T>} viene utilizzata per gestire una lista ordinata di elementi in base a un \texttt{Comparator} fornito in fase di costruzione e per navigare comodamente tra gli elementi tramite un iteratore bidirezionale specializzato (\texttt{StepIterator}).

La classe mantiene gli elementi sempre ordinati sovrascrivendo il metodo \texttt{add}, che inserisce il nuovo elemento nella posizione corretta secondo il comparatore. L'iteratore interno \texttt{StepIterator} espone operazioni di spostamento avanti/indietro e permette di posizionare il cursore su un elemento esistente.

Di seguito si riporta l'implementazione completa:

\begin{lstlisting}[language=Java]
/**
 * Lista che ordina gli elementi secondo un {@link Comparator} fornito.
 * Fornisce un iteratore bidirezionale ({@link StepIterator}) per la navigazione nella lista.
 * Utile per logiche di gioco che riguardano il posizionamento degli ascensori.
 *
 * @param <T> tipo degli elementi nella lista
 */
public class StepList<T> extends ArrayList<T> {
  private final Comparator<? super T> comparator;

  /**
   * Costruisce una nuova {@code StepList} usando il comparatore specificato.
   *
   * @param comparator comparatore per l'ordinamento degli elementi
   */
  public StepList(Comparator<? super T> comparator) {
    super();
    this.comparator = comparator;
  }

  /**
   * Aggiunge l'elemento nella posizione secondo il comparatore.
   * Sovrascrive il comportamento di {@link ArrayList#add(Object)}.
   *
   * @param element elemento da aggiungere
   * @return sempre {@code true}
   */
  @Override
  public boolean add(T element) {
    int index = 0;
    for (; index < size(); index++) {
      if (comparator.compare(element, get(index)) < 0) {
        break;
      }
    }

    super.add(index, element);
    return true;
  }

  /**
   * Restituisce un iteratore bidirezionale specializzato ({@link StepIterator})
   * che mantiene un cursore interno e permette di spostarsi avanti/indietro.
   *
   * @return nuovo {@link StepIterator}
   */
  @Override
  public StepIterator iterator() {
    return new StepIterator();
  }

  /**
   * Iteratore interno per {@link StepList} che espone operazioni forward/backward
   * e la possibilita' di posizionare il cursore su un elemento.
   */
  public class StepIterator implements Iterator<T> {
    private int cursor = 0;

    /**
     * Indica se esiste un elemento successivo rispetto al cursore.
     *
     * @return {@code true} se c'e' un elemento successivo
     */
    public boolean hasNext() {
      return cursor < size();
    }

    /**
     * Restituisce l'elemento corrente e avanza il cursore.
     *
     * @return elemento successivo
     * @throws NoSuchElementException se non ci sono elementi successivi
     */
    public T next() {
      if (!hasNext())
        throw new NoSuchElementException();
      return get(cursor++);
    }

    /**
     * Indica se esiste un elemento precedente rispetto al cursore.
     *
     * @return {@code true} se c'e' un elemento precedente
     */
    public boolean hasPrevious() {
      return cursor > 0;
    }

    /**
     * Sposta indietro il cursore e restituisce l'elemento precedente.
     *
     * @return elemento precedente
     * @throws NoSuchElementException se non ci sono elementi precedenti
     */
    public T previous() {
      if (!hasPrevious())
        throw new NoSuchElementException();
      return get(--cursor);
    }

    /**
     * Posiziona il cursore sull'elemento specificato se presente nella lista.
     *
     * @param element elemento su cui posizionare il cursore
     * @return {@code true} se l'elemento e' stato trovato e il cursore aggiornato, {@code false} altrimenti
     */
    public boolean setCursorAt(T element) {
      int index = indexOf(element);
      if (index < 0)
        return false;
      cursor = index;
      return true;
    }
  }
}
\end{lstlisting}

\subsection{ElevatorPlayerState}
\label{sec:elevator_player_state}
Codice completo della gestione dello stato del Player durante l'utilizzo di un ascensore.
\begin{lstlisting}[language=Java]
  public class ElevatorPlayerState extends PlayerState {
    private final Consumer<ElevatorEvent> elevatorEventConsumer = event -> {
        switch (event.type()) {
            case POSITION -> acceptDisplacement(event.point());
            case FINISH -> player.changeState(new IdlePlayerState(player));
            default -> {
            }
        }
    };

    private final ObservableEntity<ElevatorEvent> observable;
    private final Runnable onEnter;

    public ElevatorPlayerState(Player ctx, ObservableEntity<ElevatorEvent> elevator, Runnable onEnter) {
        super(ctx);
        this.observable = elevator;
        this.onEnter = onEnter;
    }

    /**
     * Applica lo spostamento fornito dall'evento dell'ascensore.
     *
     * @param p delta della posizione
     */
    private void acceptDisplacement(Point p) {
        player.translate(p);
    }

    /**
     * All'ingresso si annulla la fisica del player, ci si sottoscrive agli eventi
     * e si invoca l'azione di salita/discesa fornita dall'ascensore.
     */
    @Override
    public void onEnter() {
        player.physicsState.clearState();
        // Si ascoltano gli eventi di movimento/terminazione dell'ascensore
        observable.addListener(elevatorEventConsumer);
        onEnter.run();
    }

    /**
     * Al termine si ripristina la gravita e si rimuove il listener.
     */
    @Override
    public void onExit() {
        player.physicsState.forces.add(Player.GRAVITY);
        observable.removeListener(elevatorEventConsumer);
    }

    @Override
    public void handleInput(Set<Action> actions, SceneContext sceneContext) {
        handleDamageCollision(sceneContext);
    }

    @Override
    public void tick(SceneContext context, float deltaTime) {
    }
}
\end{lstlisting}

\end{document}
